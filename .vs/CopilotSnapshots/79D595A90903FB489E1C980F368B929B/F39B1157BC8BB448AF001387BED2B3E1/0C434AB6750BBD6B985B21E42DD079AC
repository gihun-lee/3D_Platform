using System.Numerics;
using VPP.Core.Attributes;
using VPP.Core.Models;
using VPP.Plugins.PointCloud.Models;
using ExecutionContext = VPP.Core.Models.ExecutionContext;

namespace VPP.Plugins.PointCloud.Nodes;

[NodeInfo("Rigid Transform", "Point Cloud/Transform", "Apply 4x4 rigid transform matrix to the active point cloud (rotation+translation)")]
public class RigidTransformNode : NodeBase
{
    public RigidTransformNode()
    {
        AddParameter<Matrix4x4>("Matrix", Matrix4x4.Identity, required: false, displayName: "Matrix", description: "4x4 transform matrix (row-major). Translation in M14,M24,M34.");
    }

    protected override Task ExecuteCoreAsync(ExecutionContext context, CancellationToken cancellationToken)
    {
        var m = GetParameter<Matrix4x4>("Matrix");

        // Prefer filtered cloud if upstream node produced one
        var source = context.Get<PointCloudData>(ExecutionContext.FilteredCloudKey);
        if (source == null)
        {
            // Fallback to the global point cloud (last connected import in execution order)
            source = context.Get<PointCloudData>(ExecutionContext.PointCloudKey);
        }
        if (source == null || source.Points.Count == 0)
        {
            return Task.CompletedTask;
        }

        var transformed = Transform(source, m);
        // Update filtered cloud to carry transformed data forward without replacing other clouds
        context.Set(ExecutionContext.FilteredCloudKey, transformed);
        context.Set("RigidTransformMatrix", m);
        return Task.CompletedTask;
    }

    private static PointCloudData Transform(PointCloudData source, Matrix4x4 m)
    {
        var result = source.Clone();
        for (int i = 0; i < result.Points.Count; i++)
        {
            var p = result.Points[i];
            var x = m.M11 * p.X + m.M12 * p.Y + m.M13 * p.Z + m.M14;
            var y = m.M21 * p.X + m.M22 * p.Y + m.M23 * p.Z + m.M24;
            var z = m.M31 * p.X + m.M32 * p.Y + m.M33 * p.Z + m.M34;
            result.Points[i] = new Vector3(x, y, z);
        }
        result.ComputeBoundingBox();
        return result;
    }
}
