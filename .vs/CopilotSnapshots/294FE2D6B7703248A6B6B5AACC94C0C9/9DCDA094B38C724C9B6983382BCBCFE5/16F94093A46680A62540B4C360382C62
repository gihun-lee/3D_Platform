using System.Numerics;
using VPP.Core.Attributes;
using VPP.Core.Models;
using VPP.Core.Interfaces;
using VPP.Plugins.PointCloud.Models;
using ExecutionContext = VPP.Core.Models.ExecutionContext;

namespace VPP.Plugins.PointCloud.Nodes;

[NodeInfo("Rigid Transform", "Point Cloud/Transform", "Apply 4x4 rigid transform matrix to the active point cloud (rotation+translation)")]
public class RigidTransformNode : NodeBase
{
    private NodeGraph? _graph;

    public RigidTransformNode()
    {
        AddParameter<Matrix4x4>("Matrix", Matrix4x4.Identity, required: false, displayName: "Matrix", description: "4x4 transform matrix (row-major). Translation in M14,M24,M34.");
    }

    public void SetGraph(NodeGraph graph)
    {
        _graph = graph;
    }

    protected override Task ExecuteCoreAsync(ExecutionContext context, CancellationToken cancellationToken)
    {
        var m = GetParameter<Matrix4x4>("Matrix");

        PointCloudData? source = null;
        string? sourceNodeId = null;

        // Find the directly connected source node (Import Node or another Transform/Filter)
        if (_graph != null)
        {
            var incomingConnection = _graph.Connections.FirstOrDefault(c => c.TargetNodeId == Id);
            if (incomingConnection != null)
            {
                sourceNodeId = incomingConnection.SourceNodeId;
                var sourceNode = _graph.Nodes.FirstOrDefault(n => n.Id == sourceNodeId);

                if (sourceNode != null)
                {
                    // Check if source is an Import Node
                    if (sourceNode.Name == "Import Point Cloud")
                    {
                        source = context.Get<PointCloudData>($"{ExecutionContext.PointCloudKey}_{sourceNodeId}");
                    }
                    // Check if source is another Transform Node (chained transforms)
                    else if (sourceNode.Name == "Rigid Transform")
                    {
                        source = context.Get<PointCloudData>($"TransformedCloud_{sourceNodeId}");
                    }
                    // Check if source is a Filter Node
                    else
                    {
                        // Try filtered cloud from upstream filter
                        source = context.Get<PointCloudData>($"FilteredCloud_{sourceNodeId}");
                    }
                }
            }
        }

        // Fallback: try standard filtered cloud key for backward compatibility
        if (source == null)
        {
            source = context.Get<PointCloudData>(ExecutionContext.FilteredCloudKey);
        }

        // Fallback: try global point cloud
        if (source == null)
        {
            source = context.Get<PointCloudData>(ExecutionContext.PointCloudKey);
        }

        if (source == null || source.Points.Count == 0)
        {
            return Task.CompletedTask;
        }

        var transformed = Transform(source, m);

        // Store transformed cloud with this node's ID so multiple transforms can coexist
        context.Set($"TransformedCloud_{Id}", transformed);

        // Also store in FilteredCloudKey for backward compatibility with downstream nodes
        context.Set(ExecutionContext.FilteredCloudKey, transformed);
        context.Set("RigidTransformMatrix", m);

        return Task.CompletedTask;
    }

    private static PointCloudData Transform(PointCloudData source, Matrix4x4 m)
    {
        var result = source.Clone();
        for (int i = 0; i < result.Points.Count; i++)
        {
            var p = result.Points[i];
            var x = m.M11 * p.X + m.M12 * p.Y + m.M13 * p.Z + m.M14;
            var y = m.M21 * p.X + m.M22 * p.Y + m.M23 * p.Z + m.M24;
            var z = m.M31 * p.X + m.M32 * p.Y + m.M33 * p.Z + m.M34;
            result.Points[i] = new Vector3(x, y, z);
        }
        result.ComputeBoundingBox();
        return result;
    }
}
