using System.Numerics;
using VPP.Core.Attributes;
using VPP.Core.Models;
using VPP.Plugins.PointCloud.Models;
using ExecutionContext = VPP.Core.Models.ExecutionContext;

namespace VPP.Plugins.PointCloud.Nodes;

[NodeInfo("Spec Inspection", "Point Cloud/Inspection", "Inspect measurements against specifications")]
public class InspectionNode : NodeBase
{
    public InspectionNode()
    {
        // Auto-inspection mode
        AddParameter<bool>("AutoInspect", false, required: false, displayName: "Auto Inspect",
            description: "Auto-inspect on execution or wait for manual trigger");

        // Specification parameters
        AddParameter<float>("ExpectedRadius", 10f, required: true, displayName: "Expected Radius (mm)",
            description: "Expected radius value");
        AddParameter<float>("RadiusTolerance", 1f, required: true, displayName: "Radius Tolerance (mm)",
            description: "Acceptable error for radius");

        AddParameter<float>("ExpectedCenterX", 0f, required: false, displayName: "Expected Center X",
            description: "Expected center X coordinate");
        AddParameter<float>("ExpectedCenterY", 0f, required: false, displayName: "Expected Center Y",
            description: "Expected center Y coordinate");
        AddParameter<float>("ExpectedCenterZ", 0f, required: false, displayName: "Expected Center Z",
            description: "Expected center Z coordinate");
        AddParameter<float>("PositionTolerance", 5f, required: false, displayName: "Position Tolerance (mm)",
            description: "Acceptable error for center position");

        AddParameter<float>("MaxFitError", 2f, required: false, displayName: "Max Fit Error (mm)",
            description: "Maximum acceptable fit error");
        AddParameter<int>("MinInliers", 10, required: false, displayName: "Min Inliers",
            description: "Minimum number of inlier points");
    }

    protected override Task ExecuteCoreAsync(ExecutionContext context, CancellationToken cancellationToken)
    {
        var autoInspect = GetParameter<bool>("AutoInspect");

        if (!autoInspect)
        {
            // Manual mode - just store circle result for later manual inspection
            var circle = context.Get<CircleDetectionResult>(ExecutionContext.CircleResultKey);
            if (circle != null)
            {
                context.Set("InspectionInputCircle", circle);
            }
            return Task.CompletedTask;
        }

        // Auto mode - perform inspection immediately
        return Task.Run(() => PerformInspection(context), cancellationToken);
    }

    public void PerformInspection(ExecutionContext context)
    {
        var circle = context.Get<CircleDetectionResult>(ExecutionContext.CircleResultKey);
        if (circle == null)
        {
            circle = context.Get<CircleDetectionResult>("InspectionInputCircle");
        }

        if (circle == null)
            throw new InvalidOperationException("No circle detection result found in context. Run Circle Detection node first.");

        // Get expected values and tolerances
        var expectedRadius = GetParameter<float>("ExpectedRadius");
        var radiusTolerance = GetParameter<float>("RadiusTolerance");
        var expectedCenterX = GetParameter<float>("ExpectedCenterX");
        var expectedCenterY = GetParameter<float>("ExpectedCenterY");
        var expectedCenterZ = GetParameter<float>("ExpectedCenterZ");
        var positionTolerance = GetParameter<float>("PositionTolerance");
        var maxFitError = GetParameter<float>("MaxFitError");
        var minInliers = GetParameter<int>("MinInliers");

        var result = new InspectionResult
        {
            Measurements = new Dictionary<string, double>
            {
                ["Radius"] = circle.Radius,
                ["CenterX"] = circle.Center.X,
                ["CenterY"] = circle.Center.Y,
                ["CenterZ"] = circle.Center.Z,
                ["FitError"] = circle.FitError,
                ["InlierCount"] = circle.InlierCount,
                ["ExpectedRadius"] = expectedRadius,
                ["RadiusTolerance"] = radiusTolerance
            }
        };

        // Check radius against expected ± tolerance
        var radiusError = Math.Abs(circle.Radius - expectedRadius);
        if (radiusError > radiusTolerance)
        {
            result.Failures.Add($"Radius {circle.Radius:F3}mm differs from expected {expectedRadius:F3}mm by {radiusError:F3}mm (tolerance: ±{radiusTolerance:F3}mm)");
        }

        // Check center position against expected ± tolerance
        var centerError = new Vector3(
            circle.Center.X - expectedCenterX,
            circle.Center.Y - expectedCenterY,
            circle.Center.Z - expectedCenterZ
        );
        var centerDistance = centerError.Length();

        if (centerDistance > positionTolerance)
        {
            result.Failures.Add($"Center position error {centerDistance:F3}mm exceeds tolerance ±{positionTolerance:F3}mm");
        }

        // Check fit error
        if (circle.FitError > maxFitError)
        {
            result.Failures.Add($"Fit error {circle.FitError:F3}mm > Max {maxFitError:F3}mm");
        }

        // Check inlier count
        if (circle.InlierCount < minInliers)
        {
            result.Failures.Add($"Inlier count {circle.InlierCount} < Min {minInliers}");
        }

        result.Pass = result.Failures.Count == 0;
        result.Message = result.Pass
            ? $"✓ PASS - Radius: {circle.Radius:F2}mm (Expected: {expectedRadius:F2}mm)"
            : $"✗ FAIL - {string.Join("; ", result.Failures)}";

        // Store in context
        context.Set("InspectionResult", result);
    }
}
