using System.Windows;
using System.Windows.Controls;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Shapes;
using VPP.App.ViewModels;
using VPP.Core.Interfaces;
using HelixToolkit.Wpf.SharpDX; // For camera types

namespace VPP.App.Views;

public partial class MainWindow : Window
{
    private MainViewModel? ViewModel => DataContext as MainViewModel;

    // Node dragging state
    private bool _isDraggingNode;
    private NodeViewModel? _draggedNode;
    private System.Windows.Point _nodeStartPosition;
    private System.Windows.Point _mouseStartPosition;
    private Dictionary<NodeViewModel, System.Windows.Point> _multiNodeStartPositions = new();

    // Box selection state
    private bool _isBoxSelecting;
    private System.Windows.Point _boxSelectionStart;

    // Connection dragging state
    private bool _isDraggingConnection;
    private NodeViewModel? _connectionSourceNode;
    private bool _isOutputPort; // true = dragging from output, false = from input
    private System.Windows.Point _dragStartPoint;

    // Connection deletion state
    private ConnectionViewModel? _lastClickedConnection;
    private DateTime _lastConnectionClickTime = DateTime.MinValue;
    private const int DoubleClickMs = 300;

    // Context menu position
    private System.Windows.Point _contextMenuPosition;

    // Node zoom settings (visual scale only)
    private const double MinZoom = 0.25;
    private const double MaxZoom = 3.0;
    private const double ZoomFactorPerDelta = 1.1; // 10% per wheel notch

    // ROI Drawing state
    private bool _isDrawingRoi;
    private System.Numerics.Vector3? _roiFirstPoint;
    private string _currentRoiShape = "Box";

    // ROI Drag Resize state
    private bool _isDraggingRoiResize;
    private bool _roiMousePressed;
    private System.Windows.Point _roiDragStartMousePos;
    private float _roiDragStartSizeX;
    private float _roiDragStartSizeY;
    private float _roiDragStartSizeZ;
    private float _roiDragStartRadius;
    private const double DragThreshold = 5.0; // pixels

    // Camera panning state
    private bool _isDraggingCamera;
    private System.Windows.Point _cameraDragStartPos;
    private System.Windows.Media.Media3D.Point3D _cameraStartPosition;
    private System.Windows.Media.Media3D.Vector3D _cameraStartLookDirection;

    // Canvas panning state
    private bool _isPanningCanvas;
    private System.Windows.Point _canvasPanStartMousePos;
    private System.Windows.Point _canvasPanStartOffset;

    public MainWindow()
    {
        InitializeComponent();

        // Add Viewport3D event handlers
        Viewport3D.MouseMove += Viewport3D_MouseMove;
        Viewport3D.MouseLeftButtonUp += Viewport3D_MouseLeftButtonUp;

        // Add keyboard event handler
        this.KeyDown += MainWindow_KeyDown;
        this.KeyUp += MainWindow_KeyUp;
    }

    private void Viewport3D_PreviewKeyDown(object sender, KeyEventArgs e)
    {
        // Prevent default camera controller WASD and QE behavior while drawing ROI
        if (ViewModel?.IsRoiDrawingMode == true)
        {
            if (e.Key is Key.W or Key.A or Key.S or Key.D or Key.Q or Key.E)
            {
                e.Handled = true; // stop camera movement
                // let our window-level MainWindow_KeyDown handle it
                MainWindow_KeyDown(sender, e);
            }
            return;
        }

        // Relative 90-degree rotation
        if (ViewModel?.Camera is Camera camera)
        {
            System.Windows.Media.Media3D.Vector3D axis = new(0, 0, 0);
            double angle = 0;
            bool rotate = false;

            switch (e.Key)
            {
                case Key.A: // Y axis (-90)
                    axis = new System.Windows.Media.Media3D.Vector3D(0, 1, 0);
                    angle = -90;
                    rotate = true;
                    break;
                case Key.D: // Y axis (+90)
                    axis = new System.Windows.Media.Media3D.Vector3D(0, 1, 0);
                    angle = 90;
                    rotate = true;
                    break;
                case Key.W: // Z axis (+90)
                    axis = new System.Windows.Media.Media3D.Vector3D(0, 0, 1);
                    angle = 90;
                    rotate = true;
                    break;
                case Key.S: // Z axis (-90)
                    axis = new System.Windows.Media.Media3D.Vector3D(0, 0, 1);
                    angle = -90;
                    rotate = true;
                    break;
                case Key.Q: // X axis (+90)
                    axis = new System.Windows.Media.Media3D.Vector3D(1, 0, 0);
                    angle = 90;
                    rotate = true;
                    break;
                case Key.E: // X axis (-90)
                    axis = new System.Windows.Media.Media3D.Vector3D(1, 0, 0);
                    angle = -90;
                    rotate = true;
                    break;
            }

            if (rotate)
            {
                RotateCamera(camera, axis, angle);
                e.Handled = true;
            }
        }
    }

    private void RotateCamera(Camera camera, System.Windows.Media.Media3D.Vector3D axis, double angle)
    {
        var lookDir = camera.LookDirection;
        var pos = camera.Position;
        var target = pos + lookDir;

        var rotation = new System.Windows.Media.Media3D.AxisAngleRotation3D(axis, angle);
        var transform = new System.Windows.Media.Media3D.RotateTransform3D(rotation);

        // Rotate position around target
        var relativePos = pos - target;
        var newRelativePos = transform.Transform(relativePos);
        var newPos = target + newRelativePos;

        // Rotate look direction
        var newLookDir = transform.Transform(lookDir);

        // Rotate up direction
        var newUpDir = transform.Transform(camera.UpDirection);

        camera.Position = newPos;
        camera.LookDirection = newLookDir;
        camera.UpDirection = newUpDir;
    }

    private void NodeCanvas_MouseWheel(object sender, MouseWheelEventArgs e)
    {
        if (ViewModel == null) return;

        // Get mouse position in canvas coordinates
        var mousePos = e.GetPosition(NodeCanvas);

        // Calculate new zoom scale
        var delta = e.Delta > 0 ? ZoomFactorPerDelta : 1.0 / ZoomFactorPerDelta;
        var oldZoom = ViewModel.NodeZoomScale;
        var newZoom = oldZoom * delta;

        // Clamp zoom
        if (newZoom < MinZoom) newZoom = MinZoom;
        if (newZoom > MaxZoom) newZoom = MaxZoom;

        // Calculate scale ratio
        var scaleRatio = newZoom / oldZoom;

        // Adjust all node positions so that the point under the mouse stays fixed
        // Formula: newPos = mousePos + (oldPos - mousePos) * scaleRatio
        foreach (var n in ViewModel.Nodes)
        {
            var oldX = n.X;
            var oldY = n.Y;

            n.X = mousePos.X + (oldX - mousePos.X) * scaleRatio;
            n.Y = mousePos.Y + (oldY - mousePos.Y) * scaleRatio;
        }

        // Update zoom scale
        ViewModel.NodeZoomScale = newZoom;

        // Update connection positions
        ViewModel.UpdateConnectionPositions();

        e.Handled = true;
    }

    private void FitCameraButton_Click(object sender, RoutedEventArgs e)
    {
        if (ViewModel?.PointCloudGeometry?.Positions == null || ViewModel.PointCloudGeometry.Positions.Count == 0 || ViewModel.Camera == null)
        {
            return;
        }
        var positions = ViewModel.PointCloudGeometry.Positions;
        var min = new SharpDX.Vector3(float.MaxValue, float.MaxValue, float.MaxValue);
        var max = new SharpDX.Vector3(float.MinValue, float.MinValue, float.MinValue);
        foreach (var p in positions)
        {
            min = SharpDX.Vector3.Min(min, p);
            max = SharpDX.Vector3.Max(max, p);
        }
        var center = (min + max) * 0.5f;
        var extents = max - min;
        float radius = extents.Length() * 0.5f;
        if (radius <= 0) radius = 1f;
        if (ViewModel.Camera is PerspectiveCamera pc)
        {
            double fovRad = pc.FieldOfView * Math.PI / 180.0;
            double distance = (radius / Math.Sin(fovRad / 2.0)) * 1.2;
            pc.Position = new System.Windows.Media.Media3D.Point3D(center.X, center.Y, center.Z + distance);
            pc.LookDirection = new System.Windows.Media.Media3D.Vector3D(0, 0, -distance);
            pc.UpDirection = new System.Windows.Media.Media3D.Vector3D(0, 1, 0);
        }
        else if (ViewModel.Camera is OrthographicCamera oc)
        {
            oc.LookDirection = new System.Windows.Media.Media3D.Vector3D(0, 0, -1);
            oc.Position = new System.Windows.Media.Media3D.Point3D(center.X, center.Y, center.Z + radius * 2);
            oc.UpDirection = new System.Windows.Media.Media3D.Vector3D(0, 1, 0);
            oc.Width = radius * 4;
        }
    }

    #region Context Menu

    private void NodeCanvas_MouseRightButtonDown(object sender, MouseButtonEventArgs e)
    {
        _contextMenuPosition = e.GetPosition(NodeCanvas);
    }

    private void AddNodeContextMenu_Opened(object sender, RoutedEventArgs e)
    {
        if (ViewModel != null)
        {
            ViewModel.NodeSearchText = "";
            ViewModel.UpdateFilteredNodes();
        }
    }

    private void NodeSearchBox_TextChanged(object sender, TextChangedEventArgs e)
    {
        ViewModel?.UpdateFilteredNodes();
    }

    private void NodeListBox_KeyDown(object sender, KeyEventArgs e)
    {
        if (e.Key == Key.Enter)
            AddSelectedNode(sender as ListBox);
    }

    private void NodeListBox_SelectionChanged(object sender, SelectionChangedEventArgs e)
    {
        if (sender is ListBox listBox && listBox.SelectedItem != null)
            AddSelectedNode(listBox);
    }

    private void AddSelectedNode(ListBox? listBox)
    {
        if (listBox?.SelectedItem is string nodeType && ViewModel != null)
        {
            // Use context menu position directly (no scale transform on canvas anymore)
            ViewModel.AddNodeAtPosition(nodeType, _contextMenuPosition.X, _contextMenuPosition.Y);
            AddNodeContextMenu.IsOpen = false;
        }
    }

    #endregion

    #region Node Dragging (Header Only)

    private void FileSelectButton_Click(object sender, RoutedEventArgs e)
    {
        if (sender is Button button && button.Tag is NodeViewModel nodeVm)
        {
            if (nodeVm.Name == "Import Point Cloud")
            {
                var dialog = new Microsoft.Win32.OpenFileDialog
                {
                    Filter = "Point Cloud Files|*.ply;*.pcd;*.xyz;*.csv;*.txt|All Files|*.*",
                    Title = "Select Point Cloud File"
                };

                if (dialog.ShowDialog() == true)
                {
                    var pathParam = nodeVm.Node.Parameters.FirstOrDefault(p => p.Name == "FilePath");
                    if (pathParam != null)
                    {
                        pathParam.Value = dialog.FileName;

                        if (ViewModel != null)
                        {
                            ViewModel.StatusMessage = $"Loading: {System.IO.Path.GetFileName(dialog.FileName)}";
                            _ = ViewModel.ExecuteGraphCommand.ExecuteAsync(null);
                        }
                    }
                }
            }
        }
    }

    private void NodeHeader_MouseMove(object sender, MouseEventArgs e)
    {
        if (_isDraggingNode && e.LeftButton == MouseButtonState.Pressed)
        {
            var currentPos = e.GetPosition(NodeCanvas);
            var delta = currentPos - _mouseStartPosition;

            // Move all selected nodes
            foreach (var kvp in _multiNodeStartPositions)
            {
                var node = kvp.Key;
                var startPos = kvp.Value;
                node.X = startPos.X + delta.X;
                node.Y = startPos.Y + delta.Y;
            }

            ViewModel?.UpdateConnectionPositions();
            e.Handled = true;
        }
    }

    private void NodeHeader_MouseLeftButtonUp(object sender, MouseButtonEventArgs e)
    {
        if (_isDraggingNode && sender is Border header)
        {
            _isDraggingNode = false;
            _draggedNode = null;
            header.ReleaseMouseCapture();
            e.Handled = true;
        }
    }

    #endregion // Node Dragging (Header Only)

    #region Port Connection Dragging

    private void OutputPort_MouseDown(object sender, MouseButtonEventArgs e)
    {
        if (sender is Ellipse ellipse && ellipse.Tag is NodeViewModel nodeVm)
        {
            StartConnectionDrag(ellipse, nodeVm, true);
            e.Handled = true;
        }
    }

    private void InputPort_MouseDown(object sender, MouseButtonEventArgs e)
    {
        if (sender is Ellipse ellipse && ellipse.Tag is NodeViewModel nodeVm)
        {
            StartConnectionDrag(ellipse, nodeVm, false);
            e.Handled = true;
        }
    }

    private void StartConnectionDrag(Ellipse port, NodeViewModel nodeVm, bool isOutput)
    {
        _isDraggingConnection = true;
        _connectionSourceNode = nodeVm;
        _isOutputPort = isOutput;

        var portCenter = port.TranslatePoint(new System.Windows.Point(6, 6), NodeCanvas);
        _dragStartPoint = portCenter;

        TempConnectionLine.Visibility = Visibility.Visible;
        UpdateTempConnectionLine(portCenter);
        // Removed NodeCanvas.CaptureMouse to allow MouseUp to reach target ellipse
    }

    private void Port_MouseUp(object sender, MouseButtonEventArgs e)
    {
        if (_isDraggingConnection && sender is Ellipse ellipse && ellipse.Tag is NodeViewModel targetNodeVm)
        {
            // Determine if this is a valid connection
            bool isTargetInput = !_isOutputPort;
            
            // Can only connect output -> input or input -> output
            if (_connectionSourceNode != null && _connectionSourceNode != targetNodeVm)
            {
                NodeViewModel sourceNode, targetNode;
                
                if (_isOutputPort)
                {
                    // Dragging from output -> must connect to input
                    sourceNode = _connectionSourceNode;
                    targetNode = targetNodeVm;
                }
                else
                {
                    // Dragging from input -> must connect from output
                    sourceNode = targetNodeVm;
                    targetNode = _connectionSourceNode;
                }

                // Create the connection
                ViewModel?.CreateConnection(sourceNode, targetNode);
            }

            EndConnectionDrag();
            e.Handled = true;
        }
    }

    private void NodeCanvas_MouseLeftButtonDown(object sender, MouseButtonEventArgs e)
    {
        // Check for Spacebar panning first
        if (Keyboard.IsKeyDown(Key.Space))
        {
            _isPanningCanvas = true;
            _canvasPanStartMousePos = e.GetPosition(this);
            _canvasPanStartOffset = new Point(NodeCanvasTranslateTransform.X, NodeCanvasTranslateTransform.Y);
            NodeCanvas.CaptureMouse();
            e.Handled = true;
            return;
        }

        // Only start box selection if clicking directly on the canvas background
        if (e.OriginalSource == NodeCanvas || e.OriginalSource == NodeGraphViewport || e.OriginalSource == sender)
        {
            _isBoxSelecting = true;
            _boxSelectionStart = e.GetPosition(NodeCanvas);
            SelectionBox.Visibility = Visibility.Visible;
            Canvas.SetLeft(SelectionBox, _boxSelectionStart.X);
            Canvas.SetTop(SelectionBox, _boxSelectionStart.Y);
            SelectionBox.Width = 0;
            SelectionBox.Height = 0;
            NodeCanvas.CaptureMouse();
            e.Handled = true;
        }
    }

    private void NodeCanvas_MouseMove(object sender, MouseEventArgs e)
    {
        if (_isPanningCanvas)
        {
            var currentPos = e.GetPosition(this);
            var delta = currentPos - _canvasPanStartMousePos;
            NodeCanvasTranslateTransform.X = _canvasPanStartOffset.X + delta.X;
            NodeCanvasTranslateTransform.Y = _canvasPanStartOffset.Y + delta.Y;
            e.Handled = true;
            return;
        }

        if (_isDraggingConnection)
        {
            var currentPos = e.GetPosition(NodeCanvas);
            UpdateTempConnectionLine(currentPos);
        }
        else if (_isBoxSelecting)
        {
            var currentPos = e.GetPosition(NodeCanvas);
            UpdateSelectionBox(_boxSelectionStart, currentPos);
        }
    }

    private void UpdateSelectionBox(System.Windows.Point start, System.Windows.Point current)
    {
        var rect = GetSelectionRect(start, current);
        Canvas.SetLeft(SelectionBox, rect.Left);
        Canvas.SetTop(SelectionBox, rect.Top);
        SelectionBox.Width = rect.Width;
        SelectionBox.Height = rect.Height;
    }

    private Rect GetSelectionRect(System.Windows.Point start, System.Windows.Point end)
    {
        var x = Math.Min(start.X, end.X);
        var y = Math.Min(start.Y, end.Y);
        var width = Math.Abs(end.X - start.X);
        var height = Math.Abs(end.Y - start.Y);
        return new Rect(x, y, width, height);
    }

    // NodeCanvas_MouseLeftButtonUp moved to Node Selection region

    private void TryConnectAtPoint(Point point)
    {
        var hit = VisualTreeHelper.HitTest(NodeCanvas, point);
        if (hit == null) return;

        // Walk up visual tree to find an Ellipse with a NodeViewModel Tag
        DependencyObject current = hit.VisualHit;
        while (current != null && current is not Ellipse)
        {
            current = VisualTreeHelper.GetParent(current);
        }
        if (current is Ellipse ellipse && ellipse.Tag is NodeViewModel targetNodeVm && _connectionSourceNode != null && targetNodeVm != _connectionSourceNode)
        {
            // Determine if ellipse is input or output by fill color
            var brush = ellipse.Fill as SolidColorBrush;
            bool targetIsInput = brush != null && brush.Color == Color.FromRgb(0x4C, 0xAF, 0x50); // Green
            bool targetIsOutput = brush != null && brush.Color == Color.FromRgb(0xFF, 0x98, 0x00); // Orange

            NodeViewModel sourceNode;
            NodeViewModel targetNode;
            if (_isOutputPort && targetIsInput)
            {
                sourceNode = _connectionSourceNode;
                targetNode = targetNodeVm;
            }
            else if (!_isOutputPort && targetIsOutput)
            {
                sourceNode = targetNodeVm;
                targetNode = _connectionSourceNode;
            }
            else
            {
                return; // incompatible port types
            }

            ViewModel?.CreateConnection(sourceNode, targetNode);
        }
    }

    private void UpdateTempConnectionLine(System.Windows.Point endPoint)
    {
        var geometry = new PathGeometry();
        var figure = new PathFigure { StartPoint = _dragStartPoint };

        // Create bezier curve
        var dx = endPoint.X - _dragStartPoint.X;
        var controlOffset = Math.Abs(dx) * 0.5;

        var control1 = _isOutputPort
            ? new System.Windows.Point(_dragStartPoint.X + controlOffset, _dragStartPoint.Y)
            : new System.Windows.Point(_dragStartPoint.X - controlOffset, _dragStartPoint.Y);

        var control2 = _isOutputPort
            ? new System.Windows.Point(endPoint.X - controlOffset, endPoint.Y)
            : new System.Windows.Point(endPoint.X + controlOffset, endPoint.Y);

        figure.Segments.Add(new BezierSegment(control1, control2, endPoint, true));
        geometry.Figures.Add(figure);
        TempConnectionLine.Data = geometry;
    }

    private void EndConnectionDrag()
    {
        _isDraggingConnection = false;
        _connectionSourceNode = null;
        TempConnectionLine.Visibility = Visibility.Collapsed;
        // Removed NodeCanvas.ReleaseMouseCapture
    }

    #endregion // Port Connection Dragging

    #region Connection Deletion (Double-Click)

    private void Connection_MouseLeftButtonDown(object sender, MouseButtonEventArgs e)
    {
        if (sender is Path path && path.Tag is ConnectionViewModel connVm)
        {
            var now = DateTime.Now;
            var timeSinceLastClick = (now - _lastConnectionClickTime).TotalMilliseconds;

            if (_lastClickedConnection == connVm && timeSinceLastClick < DoubleClickMs)
            {
                // Double-click detected - delete connection
                ViewModel?.DeleteConnection(connVm);
                _lastClickedConnection = null;
                _lastConnectionClickTime = DateTime.MinValue;
            }
            else
            {
                // First click
                _lastClickedConnection = connVm;
                _lastConnectionClickTime = now;
            }

            e.Handled = true;
        }
    }

    private void ParameterRow_MouseLeftButtonUp(object sender, MouseButtonEventArgs e)
    {
        if (sender is Border b && b.DataContext is VPP.Core.Interfaces.IParameter param)
        {
            // Ascend to find NodeViewModel
            DependencyObject current = b;
            NodeViewModel? nodeVm = null;
            while (current != null)
            {
                if (current is Border bd && bd.DataContext is NodeViewModel nvm)
                { nodeVm = nvm; break; }
                current = VisualTreeHelper.GetParent(current);
            }
            if (nodeVm == null) return;

            // FilePath handling for Import Point Cloud
            if (nodeVm.Name == "Import Point Cloud" && param.Name == "FilePath")
            {
                var dialog = new Microsoft.Win32.OpenFileDialog
                {
                    Filter = "Point Cloud Files|*.ply;*.pcd;*.xyz;*.csv;*.txt|All Files|*.*",
                    Title = "Select Point Cloud File"
                };
                if (dialog.ShowDialog() == true)
                {
                    param.Value = dialog.FileName;
                    ViewModel!.StatusMessage = $"Loaded: {System.IO.Path.GetFileName(dialog.FileName)}";
                    _ = ViewModel.ExecuteGraphCommand.ExecuteAsync(null);
                }
                return;
            }

            // Matrix editing for Rigid Transform node
            if (nodeVm.Name == "Rigid Transform" && param.Name == "Matrix")
            {
                var currentMatrix = param.Value is System.Numerics.Matrix4x4 m ? m : System.Numerics.Matrix4x4.Identity;
                var editor = new MatrixEditWindow(currentMatrix);
                editor.Owner = this;
                if (editor.ShowDialog() == true)
                {
                    param.Value = editor.ResultMatrix;
                    ViewModel!.StatusMessage = "Matrix updated";
                    // Optionally auto-execute graph to apply transform
                    _ = ViewModel.ExecuteGraphCommand.ExecuteAsync(null);
                }
                return;
            }

            // Generic parameter editor for other types
            ShowParameterEditor(param, nodeVm);
        }
    }

    private void ShowParameterEditor(VPP.Core.Interfaces.IParameter param, NodeViewModel nodeVm)
    {
        var paramType = param.Value?.GetType();
        if (paramType == null) return;

        // Boolean parameters - toggle
        if (paramType == typeof(bool))
        {
            param.Value = !(bool)param.Value;
            ViewModel!.StatusMessage = $"{param.Name} = {param.Value}";
            _ = ViewModel.ExecuteGraphCommand.ExecuteAsync(null);
            return;
        }

        // Numeric parameters - show input dialog
        if (paramType == typeof(int) || paramType == typeof(float) || paramType == typeof(double))
        {
            var inputDialog = new Window
            {
                Title = $"Edit {param.Name}",
                // Make the window fit its content and allow resizing
                SizeToContent = SizeToContent.WidthAndHeight,
                MinWidth = 360,
                WindowStartupLocation = WindowStartupLocation.CenterOwner,
                Owner = this,
                Background = new SolidColorBrush(Color.FromRgb(42, 42, 42)),
                WindowStyle = WindowStyle.ToolWindow,
                ResizeMode = ResizeMode.CanResizeWithGrip
            };

            var grid = new Grid { Margin = new Thickness(15) };
            grid.RowDefinitions.Add(new RowDefinition { Height = GridLength.Auto });
            grid.RowDefinitions.Add(new RowDefinition { Height = GridLength.Auto });
            grid.RowDefinitions.Add(new RowDefinition { Height = GridLength.Auto });
            grid.RowDefinitions.Add(new RowDefinition { Height = GridLength.Auto });

            // Label
            var label = new TextBlock
            {
                Text = param.Name,
                Foreground = Brushes.White,
                FontSize = 14,
                FontWeight = FontWeights.SemiBold,
                Margin = new Thickness(0, 0, 0, 8)
            };
            Grid.SetRow(label, 0);
            grid.Children.Add(label);

            // Description (if available)
            if (!string.IsNullOrEmpty(param.Description))
            {
                var desc = new TextBlock
                {
                    Text = param.Description,
                    Foreground = new SolidColorBrush(Color.FromRgb(180, 180, 180)),
                    FontSize = 10,
                    TextWrapping = TextWrapping.Wrap,
                    Margin = new Thickness(0, 0, 0, 12)
                };
                Grid.SetRow(desc, 1);
                grid.Children.Add(desc);
            }

            // TextBox
            var textBox = new TextBox
            {
                Text = param.Value.ToString(),
                FontSize = 13,
                Padding = new Thickness(8, 6, 8, 6),
                Background = new SolidColorBrush(Color.FromRgb(35, 35, 35)),
                Foreground = Brushes.White,
                CaretBrush = Brushes.White,
                SelectionBrush = new SolidColorBrush(Color.FromRgb(0, 120, 215)),
                BorderBrush = new SolidColorBrush(Color.FromRgb(100, 100, 100)),
                BorderThickness = new Thickness(1),
                VerticalAlignment = VerticalAlignment.Top,
                HorizontalAlignment = HorizontalAlignment.Stretch,
                Margin = new Thickness(0, 0, 0, 15),
                MinWidth = 320
            };
            Grid.SetRow(textBox, 2);
            grid.Children.Add(textBox);

            // Buttons panel
            var buttonPanel = new StackPanel
            {
                Orientation = Orientation.Horizontal,
                HorizontalAlignment = HorizontalAlignment.Right
            };
            Grid.SetRow(buttonPanel, 3);

            var okButton = new Button
            {
                Content = "OK",
                Width = 80,
                Height = 30,
                Margin = new Thickness(0, 0, 8, 0),
                Background = new SolidColorBrush(Color.FromRgb(0, 188, 212)),
                Foreground = Brushes.White,
                BorderThickness = new Thickness(0),
                Cursor = Cursors.Hand
            };
            okButton.Click += (s, e) => { inputDialog.DialogResult = true; inputDialog.Close(); };

            var cancelButton = new Button
            {
                Content = "Cancel",
                Width = 80,
                Height = 30,
                Background = new SolidColorBrush(Color.FromRgb(80, 80, 80)),
                Foreground = Brushes.White,
                BorderThickness = new Thickness(0),
                Cursor = Cursors.Hand
            };
            cancelButton.Click += (s, e) => { inputDialog.DialogResult = false; inputDialog.Close(); };

            buttonPanel.Children.Add(okButton);
            buttonPanel.Children.Add(cancelButton);
            grid.Children.Add(buttonPanel);

            inputDialog.Content = grid;

            // Focus textbox and select all
            textBox.Focus();
            textBox.SelectAll();
            textBox.KeyDown += (s, e) =>
            {
                if (e.Key == System.Windows.Input.Key.Enter) { inputDialog.DialogResult = true; inputDialog.Close(); }
                if (e.Key == System.Windows.Input.Key.Escape) { inputDialog.DialogResult = false; inputDialog.Close(); }
            };

            if (inputDialog.ShowDialog() == true)
            {
                try
                {
                    if (paramType == typeof(int))
                        param.Value = int.Parse(textBox.Text);
                    else if (paramType == typeof(float))
                        param.Value = float.Parse(textBox.Text);
                    else if (paramType == typeof(double))
                        param.Value = double.Parse(textBox.Text);

                    ViewModel!.StatusMessage = $"{param.Name} = {param.Value}";
                    _ = ViewModel.ExecuteGraphCommand.ExecuteAsync(null);
                }
                catch
                {
                    ViewModel!.StatusMessage = $"Invalid value for {param.Name}";
                }
            }
        }
    }

    #endregion

    #region ROI Drawing

    private void RoiShapeBox_Click(object sender, RoutedEventArgs e)
    {
        _currentRoiShape = "Box";
        _isDrawingRoi = false;
        _roiFirstPoint = null;
        if (ViewModel?.SelectedRoiNode?.Node != null)
        {
            var shapeParam = ViewModel.SelectedRoiNode.Node.Parameters.FirstOrDefault(p => p.Name == "Shape");
            if (shapeParam != null) shapeParam.Value = "Box";
            ViewModel.StatusMessage = "Drawing Box ROI - Click two points in 3D viewer (center, then corner)";
        }
    }

    private void RoiShapeCylinder_Click(object sender, RoutedEventArgs e)
    {
        _currentRoiShape = "Cylinder";
        _isDrawingRoi = false;
        _roiFirstPoint = null;
        if (ViewModel?.SelectedRoiNode?.Node != null)
        {
            var shapeParam = ViewModel.SelectedRoiNode.Node.Parameters.FirstOrDefault(p => p.Name == "Shape");
            if (shapeParam != null) shapeParam.Value = "Cylinder";
            ViewModel.StatusMessage = "Drawing Cylinder ROI - Click two points in 3D viewer (center, then edge point)";
        }
    }

    private void RoiShapeSphere_Click(object sender, RoutedEventArgs e)
    {
        _currentRoiShape = "Sphere";
        _isDrawingRoi = false;
        _roiFirstPoint = null;
        if (ViewModel?.SelectedRoiNode?.Node != null)
        {
            var shapeParam = ViewModel.SelectedRoiNode.Node.Parameters.FirstOrDefault(p => p.Name == "Shape");
            if (shapeParam != null) shapeParam.Value = "Sphere";
            ViewModel.StatusMessage = "Drawing Sphere ROI - Click two points in 3D viewer (center, then surface point)";
        }
    }

    private void Viewport3D_MouseLeftButtonDown(object sender, MouseButtonEventArgs e)
    {
        // Handle camera panning when not in ROI mode
        if (ViewModel == null || !ViewModel.IsRoiDrawingMode || ViewModel.SelectedRoiNode == null)
        {
            // Start camera panning
            _isDraggingCamera = true;
            _cameraDragStartPos = e.GetPosition(Viewport3D);

            if (ViewModel?.Camera is PerspectiveCamera perspCam)
            {
                _cameraStartPosition = perspCam.Position;
                _cameraStartLookDirection = perspCam.LookDirection;
            }
            else if (ViewModel?.Camera is OrthographicCamera orthoCam)
            {
                _cameraStartPosition = orthoCam.Position;
                _cameraStartLookDirection = orthoCam.LookDirection;
            }

            Viewport3D.CaptureMouse();
            e.Handled = true;
            return;
        }

        var position = e.GetPosition(Viewport3D);

        // Record mouse press for potential drag
        _roiMousePressed = true;
        _roiDragStartMousePos = position;

        var node = ViewModel.SelectedRoiNode.Node;
        _roiDragStartSizeX = GetParameterValue<float>(node, "SizeX");
        _roiDragStartSizeY = GetParameterValue<float>(node, "SizeY");
        _roiDragStartSizeZ = GetParameterValue<float>(node, "SizeZ");
        _roiDragStartRadius = GetParameterValue<float>(node, "Radius");

        Viewport3D.CaptureMouse();
    }

    private void Viewport3D_MouseMove(object sender, MouseEventArgs e)
    {
        var currentPos = e.GetPosition(Viewport3D);
        // Handle camera panning
        if (_isDraggingCamera && e.LeftButton == MouseButtonState.Pressed)
        {
            var delta = currentPos - _cameraDragStartPos;

            // Pan the camera based on mouse movement
            if (ViewModel?.Camera is PerspectiveCamera perspCam)
            {
                // Calculate right and up vectors
                var lookDir = perspCam.LookDirection;
                var upDir = perspCam.UpDirection;
                var rightDir = System.Windows.Media.Media3D.Vector3D.CrossProduct(lookDir, upDir);
                rightDir.Normalize();
                upDir = System.Windows.Media.Media3D.Vector3D.CrossProduct(rightDir, lookDir);
                upDir.Normalize();

                // Scale movement based on distance from camera
                var distance = lookDir.Length;
                var movementScale = distance * 0.001; // Adjust sensitivity

                // Update camera position
                var panOffset = rightDir * (-delta.X * movementScale) + upDir * (delta.Y * movementScale);
                perspCam.Position = _cameraStartPosition + panOffset;
            }
            else if (ViewModel?.Camera is OrthographicCamera orthoCam)
            {
                // Calculate right and up vectors
                var lookDir = orthoCam.LookDirection;
                var upDir = orthoCam.UpDirection;
                var rightDir = System.Windows.Media.Media3D.Vector3D.CrossProduct(lookDir, upDir);
                rightDir.Normalize();
                upDir = System.Windows.Media.Media3D.Vector3D.CrossProduct(rightDir, lookDir);
                upDir.Normalize();

                // Scale movement based on orthographic width
                var movementScale = orthoCam.Width * 0.001; // Adjust sensitivity

                // Update camera position
                var panOffset = rightDir * (-delta.X * movementScale) + upDir * (delta.Y * movementScale);
                orthoCam.Position = _cameraStartPosition + panOffset;
            }

            e.Handled = true;
            return;
        }

        if (ViewModel?.SelectedRoiNode?.Node == null)
            return;

        // Check if we should start dragging
        if (_roiMousePressed && !_isDraggingRoiResize)
        {
            var delta = currentPos - _roiDragStartMousePos;
            var distance = Math.Sqrt(delta.X * delta.X + delta.Y * delta.Y);

            if (distance > DragThreshold)
            {
                _isDraggingRoiResize = true;
                if (ViewModel != null)
                    ViewModel.StatusMessage = "Drag up to enlarge, down to shrink ROI";
            }
            else
            {
                return; // Not dragging yet
            }
        }

        if (!_isDraggingRoiResize)
            return;

        var deltaY = _roiDragStartMousePos.Y - currentPos.Y; // Up is positive

        // Scale factor: 1 pixel = 0.1 units of size change
        var scaleFactor = (float)(deltaY * 0.1);
        var multiplier = 1.0f + scaleFactor / 10.0f;

        if (multiplier < 0.1f) multiplier = 0.1f; // Minimum size

        var node = ViewModel.SelectedRoiNode.Node;
        var shapeStr = GetParameterValue<string>(node, "Shape") ?? "Box";

        if (shapeStr == "Box")
        {
            var newSizeX = _roiDragStartSizeX * multiplier;
            var newSizeY = _roiDragStartSizeY * multiplier;
            var newSizeZ = _roiDragStartSizeZ * multiplier;

            var sizeXParam = node.Parameters.FirstOrDefault(p => p.Name == "SizeX");
            var sizeYParam = node.Parameters.FirstOrDefault(p => p.Name == "SizeY");
            var sizeZParam = node.Parameters.FirstOrDefault(p => p.Name == "SizeZ");

            if (sizeXParam != null) sizeXParam.Value = Math.Max(0.1f, newSizeX);
            if (sizeYParam != null) sizeYParam.Value = Math.Max(0.1f, newSizeY);
            if (sizeZParam != null) sizeZParam.Value = Math.Max(0.1f, newSizeZ);
        }
        else if (shapeStr == "Cylinder")
        {
            var newRadius = _roiDragStartRadius * multiplier;
            var newSizeY = _roiDragStartSizeY * multiplier;

            var radiusParam = node.Parameters.FirstOrDefault(p => p.Name == "Radius");
            var sizeYParam = node.Parameters.FirstOrDefault(p => p.Name == "SizeY");

            if (radiusParam != null) radiusParam.Value = Math.Max(0.1f, newRadius);
            if (sizeYParam != null) sizeYParam.Value = Math.Max(0.1f, newSizeY);
        }
        else if (shapeStr == "Sphere")
        {
            var newRadius = _roiDragStartRadius * multiplier;

            var radiusParam = node.Parameters.FirstOrDefault(p => p.Name == "Radius");
            if (radiusParam != null) radiusParam.Value = Math.Max(0.1f, newRadius);
        }

        // Update visualization
        ViewModel.UpdateRoiFromParameters(ViewModel.SelectedRoiNode);

        e.Handled = true;
    }

    private void Viewport3D_MouseLeftButtonUp(object sender, MouseButtonEventArgs e)
    {
        // Handle camera panning release
        if (_isDraggingCamera)
        {
            _isDraggingCamera = false;
            Viewport3D.ReleaseMouseCapture();
            e.Handled = true;
            return;
        }

        if (_isDraggingRoiResize)
        {
            _isDraggingRoiResize = false;
            _roiMousePressed = false;
            Viewport3D.ReleaseMouseCapture();
            if (ViewModel != null)
                ViewModel.StatusMessage = "ROI size updated";
            e.Handled = true;
        }
        else if (_roiMousePressed)
        {
            // This was a click, not a drag - handle ROI point selection
            _roiMousePressed = false;
            Viewport3D.ReleaseMouseCapture();

            var position = e.GetPosition(Viewport3D);
            var hitPoint = GetHitPoint(position);

            if (hitPoint == null)
            {
                if (ViewModel != null)
                    ViewModel.StatusMessage = "Click on a point in the point cloud";
                return;
            }

            if (!_roiFirstPoint.HasValue)
            {
                // First click - set center
                _roiFirstPoint = hitPoint.Value;
                _isDrawingRoi = true;
                if (ViewModel != null)
                    ViewModel.StatusMessage = $"Center set at ({hitPoint.Value.X:F2}, {hitPoint.Value.Y:F2}, {hitPoint.Value.Z:F2}) - Click second point";
            }
            else
            {
                // Second click - set size/radius
                var center = _roiFirstPoint.Value;
                var secondPoint = hitPoint.Value;

                UpdateRoiParameters(center, secondPoint);

                _isDrawingRoi = false;
                _roiFirstPoint = null;
                if (ViewModel != null)
                    ViewModel.StatusMessage = "ROI updated - Select another shape or background to exit drawing mode";

                e.Handled = true;
            }
        }
    }

    private T GetParameterValue<T>(INode node, string paramName)
    {
        var param = node.Parameters.FirstOrDefault(p => p.Name == paramName);
        if (param?.Value is T value)
            return value;
        return default!;
    }

    private System.Numerics.Vector3? GetHitPoint(System.Windows.Point mousePosition)
    {
        if (ViewModel?.PointCloudGeometry?.Positions == null || ViewModel.PointCloudGeometry.Positions.Count == 0)
            return null;

        // Use camera ray casting to find nearest point
        var viewport = Viewport3D;
        var camera = ViewModel.Camera;

        if (camera is PerspectiveCamera perspCam)
        {
            // Convert 2D screen point to 3D world ray
            var ray = GetRay(perspCam, mousePosition, viewport.ActualWidth, viewport.ActualHeight);

            // Find closest point cloud point to ray
            var positions = ViewModel.PointCloudGeometry.Positions;
            float minDist = float.MaxValue;
            System.Numerics.Vector3? closestPoint = null;

            foreach (var p in positions)
            {
                var point = new System.Numerics.Vector3(p.X, p.Y, p.Z);
                var dist = DistanceToRay(point, ray.origin, ray.direction);
                if (dist < minDist)
                {
                    minDist = dist;
                    closestPoint = point;
                }
            }

            // Only return if reasonably close
            if (minDist < 50f)
                return closestPoint;
        }

        return null;
    }

    private (System.Numerics.Vector3 origin, System.Numerics.Vector3 direction) GetRay(PerspectiveCamera camera, System.Windows.Point screenPoint, double width, double height)
    {
        var origin = new System.Numerics.Vector3(
            (float)camera.Position.X,
            (float)camera.Position.Y,
            (float)camera.Position.Z);

        // Simple approximation - convert screen point to world direction
        var lookDir = new System.Numerics.Vector3(
            (float)camera.LookDirection.X,
            (float)camera.LookDirection.Y,
            (float)camera.LookDirection.Z);

        var upDir = new System.Numerics.Vector3(
            (float)camera.UpDirection.X,
            (float)camera.UpDirection.Y,
            (float)camera.UpDirection.Z);

        var rightDir = System.Numerics.Vector3.Cross(lookDir, upDir);
        rightDir = System.Numerics.Vector3.Normalize(rightDir);
        upDir = System.Numerics.Vector3.Cross(rightDir, lookDir);
        upDir = System.Numerics.Vector3.Normalize(upDir);

        var fov = camera.FieldOfView * Math.PI / 180.0;
        var aspectRatio = width / height;

        var dx = (float)((screenPoint.X / width - 0.5) * 2 * Math.Tan(fov / 2) * aspectRatio);
        var dy = (float)((0.5 - screenPoint.Y / height) * 2 * Math.Tan(fov / 2));

        var direction = lookDir + rightDir * dx + upDir * dy;
        direction = System.Numerics.Vector3.Normalize(direction);

        return (origin, direction);
    }

    private float DistanceToRay(System.Numerics.Vector3 point, System.Numerics.Vector3 rayOrigin, System.Numerics.Vector3 rayDirection)
    {
        var toPoint = point - rayOrigin;
        var projection = System.Numerics.Vector3.Dot(toPoint, rayDirection);
        var closestPointOnRay = rayOrigin + rayDirection * projection;
        return System.Numerics.Vector3.Distance(point, closestPointOnRay);
    }

    private void UpdateRoiParameters(System.Numerics.Vector3 center, System.Numerics.Vector3 secondPoint)
    {
        if (ViewModel?.SelectedRoiNode?.Node == null) return;

        var node = ViewModel.SelectedRoiNode.Node;

        // Set center
        var centerXParam = node.Parameters.FirstOrDefault(p => p.Name == "CenterX");
        var centerYParam = node.Parameters.FirstOrDefault(p => p.Name == "CenterY");
        var centerZParam = node.Parameters.FirstOrDefault(p => p.Name == "CenterZ");
        if (centerXParam != null) centerXParam.Value = center.X;
        if (centerYParam != null) centerYParam.Value = center.Y;
        if (centerZParam != null) centerZParam.Value = center.Z;

        if (_currentRoiShape == "Box")
        {
            // Calculate box size (center to corner * 2)
            var size = System.Numerics.Vector3.Abs(secondPoint - center) * 2;
            var sizeXParam = node.Parameters.FirstOrDefault(p => p.Name == "SizeX");
            var sizeYParam = node.Parameters.FirstOrDefault(p => p.Name == "SizeY");
            var sizeZParam = node.Parameters.FirstOrDefault(p => p.Name == "SizeZ");
            if (sizeXParam != null) sizeXParam.Value = size.X;
            if (sizeYParam != null) sizeYParam.Value = size.Y;
            if (sizeZParam != null) sizeZParam.Value = size.Z;
        }
        else if (_currentRoiShape == "Cylinder" || _currentRoiShape == "Sphere")
        {
            // Calculate radius
            float radius;
            if (_currentRoiShape == "Cylinder")
            {
                // Radius in XZ plane
                var dx = secondPoint.X - center.X;
                var dz = secondPoint.Z - center.Z;
                radius = MathF.Sqrt(dx * dx + dz * dz);

                // Height from Y difference
                var height = MathF.Abs(secondPoint.Y - center.Y) * 2;
                var sizeYParam = node.Parameters.FirstOrDefault(p => p.Name == "SizeY");
                if (sizeYParam != null) sizeYParam.Value = Math.Max(height, 1f);
            }
            else
            {
                // Sphere - 3D distance
                radius = System.Numerics.Vector3.Distance(center, secondPoint);
            }

            var radiusParam = node.Parameters.FirstOrDefault(p => p.Name == "Radius");
            if (radiusParam != null) radiusParam.Value = Math.Max(radius, 0.1f);
        }

        // Update visualization
        ViewModel.UpdateRoiFromParameters(ViewModel.SelectedRoiNode);
    }

    private void MainWindow_KeyDown(object sender, KeyEventArgs e)
    {
        if (ViewModel == null)
            return;

        // Space key: Panning mode cursor
        if (e.Key == Key.Space)
        {
            NodeGraphViewport.Cursor = Cursors.SizeAll;
            NodeGraphViewport.ForceCursor = true;
        }

        // Delete key: delete all selected nodes
        if (e.Key == Key.Delete)
        {
            var selectedNodes = ViewModel.Nodes.Where(n => n.IsSelected).ToList();
            foreach (var n in selectedNodes)
            {
                ViewModel.DeleteNode(n);
            }
            if (selectedNodes.Count > 0)
            {
                e.Handled = true;
                return;
            }
        }

        // Ctrl+A: select all nodes
        if (e.Key == Key.A && (Keyboard.IsKeyDown(Key.LeftCtrl) || Keyboard.IsKeyDown(Key.RightCtrl)))
        {
            foreach (var n in ViewModel.Nodes)
            {
                n.IsSelected = true;
            }
            e.Handled = true;
            return;
        }

        // Escape: deselect all nodes
        if (e.Key == Key.Escape)
        {
            foreach (var n in ViewModel.Nodes)
            {
                n.IsSelected = false;
            }
            ViewModel.SelectNode(null);
            e.Handled = true;
            return;
        }

        // ROI drawing mode keyboard controls
        if (!ViewModel.IsRoiDrawingMode || ViewModel.SelectedRoiNode?.Node == null)
            return;

        var roiNode = ViewModel.SelectedRoiNode.Node;
        var centerXParam = roiNode.Parameters.FirstOrDefault(p => p.Name == "CenterX");
        var centerYParam = roiNode.Parameters.FirstOrDefault(p => p.Name == "CenterY");
        var centerZParam = roiNode.Parameters.FirstOrDefault(p => p.Name == "CenterZ");

        if (centerXParam == null || centerYParam == null || centerZParam == null)
            return;

        float moveStep = 1.0f;

        // Check if Shift is pressed for larger steps
        if (Keyboard.IsKeyDown(Key.LeftShift) || Keyboard.IsKeyDown(Key.RightShift))
            moveStep = 5.0f;

        bool moved = false;

        switch (e.Key)
        {
            case Key.W:
                // Move forward (positive Z)
                centerZParam.Value = (float)centerZParam.Value + moveStep;
                moved = true;
                break;
            case Key.S:
                // Move backward (negative Z)
                centerZParam.Value = (float)centerZParam.Value - moveStep;
                moved = true;
                break;
            case Key.A:
                // Move left (negative X)
                centerXParam.Value = (float)centerXParam.Value - moveStep;
                moved = true;
                break;
            case Key.D:
                // Move right (positive X)
                centerXParam.Value = (float)centerXParam.Value + moveStep;
                moved = true;
                break;
            case Key.Q:
                // Move down (negative Y)
                centerYParam.Value = (float)centerYParam.Value - moveStep;
                moved = true;
                break;
            case Key.E:
                // Move up (positive Y)
                centerYParam.Value = (float)centerYParam.Value + moveStep;
                moved = true;
                break;
        }

        if (moved)
        {
            ViewModel.UpdateRoiFromParameters(ViewModel.SelectedRoiNode);
            ViewModel.StatusMessage = $"ROI Center moved to ({centerXParam.Value:F2}, {centerYParam.Value:F2}, {centerZParam.Value:F2})";
            e.Handled = true;
        }
    }

    private void MainWindow_KeyUp(object sender, KeyEventArgs e)
    {
        if (e.Key == Key.Space)
        {
            NodeGraphViewport.Cursor = Cursors.Arrow;
            NodeGraphViewport.ForceCursor = false;
        }
    }

    #endregion

    #region Node Selection

    private void NodeHeader_MouseLeftButtonDown(object sender, MouseButtonEventArgs e)
    {
        if (sender is Border header && header.DataContext is NodeViewModel nodeVm)
        {
            // Double-click: delete node
            if (e.ClickCount == 2)
            {
                ViewModel?.DeleteNode(nodeVm);
                e.Handled = true;
                return;
            }

            // Don't start dragging if clicking a button
            if (e.OriginalSource is Button)
            {
                e.Handled = true;
                return;
            }

            // Ctrl+Click: toggle selection
            if (Keyboard.IsKeyDown(Key.LeftCtrl) || Keyboard.IsKeyDown(Key.RightCtrl))
            {
                nodeVm.IsSelected = !nodeVm.IsSelected;
                e.Handled = true;
                return;
            }

            // Single click: select node (or start dragging if already selected)
            if (!nodeVm.IsSelected)
            {
                ViewModel?.SelectNode(nodeVm);
            }

            // Start dragging the node (or all selected nodes)
            _isDraggingNode = true;
            _draggedNode = nodeVm;
            _mouseStartPosition = e.GetPosition(NodeCanvas);

            // Store start positions for all selected nodes
            _multiNodeStartPositions.Clear();
            if (ViewModel != null)
            {
                foreach (var n in ViewModel.Nodes.Where(n => n.IsSelected))
                {
                    _multiNodeStartPositions[n] = new System.Windows.Point(n.X, n.Y);
                }
            }

            header.CaptureMouse();
            e.Handled = true;
        }
    }

    private void NodeCanvas_MouseLeftButtonUp(object sender, MouseButtonEventArgs e)
    {
        if (_isPanningCanvas)
        {
            _isPanningCanvas = false;
            NodeCanvas.ReleaseMouseCapture();
            e.Handled = true;
            return;
        }

        if (_isDraggingConnection)
        {
            // Fallback: if user released over canvas (target ellipse didn't get MouseUp) perform hit test
            var releasePoint = e.GetPosition(NodeCanvas);
            TryConnectAtPoint(releasePoint);
            EndConnectionDrag();
        }
        else if (_isBoxSelecting)
        {
            // Complete box selection
            var currentPos = e.GetPosition(NodeCanvas);
            var selectionRect = GetSelectionRect(_boxSelectionStart, currentPos);

            // Select all nodes within the box
            if (ViewModel != null)
            {
                bool ctrlPressed = Keyboard.IsKeyDown(Key.LeftCtrl) || Keyboard.IsKeyDown(Key.RightCtrl);

                if (!ctrlPressed)
                {
                    // Clear existing selection if Ctrl is not pressed
                    foreach (var n in ViewModel.Nodes)
                    {
                        n.IsSelected = false;
                    }
                }

                foreach (var n in ViewModel.Nodes)
                {
                    var nodeRect = new Rect(n.X, n.Y, 200 * ViewModel.NodeZoomScale, 100 * ViewModel.NodeZoomScale);
                    if (selectionRect.IntersectsWith(nodeRect))
                    {
                        n.IsSelected = true;
                    }
                }
            }

            _isBoxSelecting = false;
            SelectionBox.Visibility = Visibility.Collapsed;
            NodeCanvas.ReleaseMouseCapture();
        }
        else if (!_isDraggingNode)
        {
            // Click on background - deselect all nodes (unless Ctrl is pressed)
            bool ctrlPressed = Keyboard.IsKeyDown(Key.LeftCtrl) || Keyboard.IsKeyDown(Key.RightCtrl);
            if (!ctrlPressed)
            {
                ViewModel?.SelectNode(null);
            }
        }
    }

    #endregion

    private void DetectButton_Click(object sender, RoutedEventArgs e)
    {

    }
}
