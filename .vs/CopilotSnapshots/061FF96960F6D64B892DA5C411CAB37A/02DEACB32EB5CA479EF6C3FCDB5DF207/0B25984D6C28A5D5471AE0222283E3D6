using System.Windows;
using System.Windows.Controls;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Shapes;
using VPP.App.ViewModels;
using VPP.Core.Interfaces;
using HelixToolkit.Wpf.SharpDX; // For camera types

namespace VPP.App.Views;

public partial class MainWindow : Window
{
    private MainViewModel? ViewModel => DataContext as MainViewModel;

    // Node dragging state
    private bool _isDraggingNode;
    private NodeViewModel? _draggedNode;
    private System.Windows.Point _nodeStartPosition;
    private System.Windows.Point _mouseStartPosition;

    // Connection dragging state
    private bool _isDraggingConnection;
    private NodeViewModel? _connectionSourceNode;
    private bool _isOutputPort; // true = dragging from output, false = from input
    private System.Windows.Point _dragStartPoint;

    // Connection deletion state
    private ConnectionViewModel? _lastClickedConnection;
    private DateTime _lastConnectionClickTime = DateTime.MinValue;
    private const int DoubleClickMs = 300;

    // Context menu position
    private System.Windows.Point _contextMenuPosition;

    // Zoom/Pan state
    private double _currentZoom = 1.0;
    private const double MinZoom = 0.25;
    private const double MaxZoom = 3.0;
    private const double ZoomFactorPerDelta = 1.1; // 10% per wheel notch

    // ROI Drawing state
    private bool _isDrawingRoi;
    private System.Numerics.Vector3? _roiFirstPoint;
    private string _currentRoiShape = "Box";

    public MainWindow()
    {
        InitializeComponent();

        NodeCanvas.MouseMove += NodeCanvas_MouseMove;
        NodeCanvas.MouseLeftButtonUp += NodeCanvas_MouseLeftButtonUp;
    }

    private void NodeCanvas_MouseWheel(object sender, MouseWheelEventArgs e)
    {
        // Zoom centered on mouse position (world point stays under cursor)
        var position = e.GetPosition(NodeCanvas);
        var delta = e.Delta > 0 ? ZoomFactorPerDelta : 1.0 / ZoomFactorPerDelta;
        var newZoom = _currentZoom * delta;
        if (newZoom < MinZoom) newZoom = MinZoom;
        if (newZoom > MaxZoom) newZoom = MaxZoom;

        // Adjust translation so that (position) remains stable
        var scale = newZoom / _currentZoom;
        var tg = (TransformGroup)NodeCanvas.RenderTransform;
        var st = (ScaleTransform)tg.Children[0];
        var tt = (TranslateTransform)tg.Children[1];

        // Translate mouse point to content coordinates before scaling
        // (position - translation) / oldScale gives content coordinate
        var contentX = (position.X - tt.X) / _currentZoom;
        var contentY = (position.Y - tt.Y) / _currentZoom;

        _currentZoom = newZoom;
        st.ScaleX = _currentZoom;
        st.ScaleY = _currentZoom;

        // New translation keeps content point under cursor: cursor = content * newScale + newTranslation
        tt.X = position.X - contentX * _currentZoom;
        tt.Y = position.Y - contentY * _currentZoom;

        e.Handled = true;
    }

    private void FitCameraButton_Click(object sender, RoutedEventArgs e)
    {
        if (ViewModel?.PointCloudGeometry?.Positions == null || ViewModel.PointCloudGeometry.Positions.Count == 0 || ViewModel.Camera == null)
        {
            return;
        }
        var positions = ViewModel.PointCloudGeometry.Positions;
        var min = new SharpDX.Vector3(float.MaxValue, float.MaxValue, float.MaxValue);
        var max = new SharpDX.Vector3(float.MinValue, float.MinValue, float.MinValue);
        foreach (var p in positions)
        {
            min = SharpDX.Vector3.Min(min, p);
            max = SharpDX.Vector3.Max(max, p);
        }
        var center = (min + max) * 0.5f;
        var extents = max - min;
        float radius = extents.Length() * 0.5f;
        if (radius <= 0) radius = 1f;
        if (ViewModel.Camera is PerspectiveCamera pc)
        {
            double fovRad = pc.FieldOfView * Math.PI / 180.0;
            double distance = (radius / Math.Sin(fovRad / 2.0)) * 1.2;
            pc.Position = new System.Windows.Media.Media3D.Point3D(center.X, center.Y, center.Z + distance);
            pc.LookDirection = new System.Windows.Media.Media3D.Vector3D(0, 0, -distance);
            pc.UpDirection = new System.Windows.Media.Media3D.Vector3D(0, 1, 0);
        }
        else if (ViewModel.Camera is OrthographicCamera oc)
        {
            oc.LookDirection = new System.Windows.Media.Media3D.Vector3D(0, 0, -1);
            oc.Position = new System.Windows.Media.Media3D.Point3D(center.X, center.Y, center.Z + radius * 2);
            oc.UpDirection = new System.Windows.Media.Media3D.Vector3D(0, 1, 0);
            oc.Width = radius * 4;
        }
    }

    #region Context Menu

    private void NodeCanvas_MouseRightButtonDown(object sender, MouseButtonEventArgs e)
    {
        _contextMenuPosition = e.GetPosition(NodeCanvas);
    }

    private void AddNodeContextMenu_Opened(object sender, RoutedEventArgs e)
    {
        if (ViewModel != null)
        {
            ViewModel.NodeSearchText = "";
            ViewModel.UpdateFilteredNodes();
        }
    }

    private void NodeSearchBox_TextChanged(object sender, TextChangedEventArgs e)
    {
        ViewModel?.UpdateFilteredNodes();
    }

    private void NodeListBox_KeyDown(object sender, KeyEventArgs e)
    {
        if (e.Key == Key.Enter)
            AddSelectedNode(sender as ListBox);
    }

    private void NodeListBox_SelectionChanged(object sender, SelectionChangedEventArgs e)
    {
        if (sender is ListBox listBox && listBox.SelectedItem != null)
            AddSelectedNode(listBox);
    }

    private void AddSelectedNode(ListBox? listBox)
    {
        if (listBox?.SelectedItem is string nodeType && ViewModel != null)
        {
            // Convert context menu position from screen to canvas (already in canvas coordinates including transform) -> need inverse transform to store logical coordinates
            var tg = (TransformGroup)NodeCanvas.RenderTransform;
            var inverse = tg.Inverse;
            var logicalPoint = inverse.Transform(_contextMenuPosition);
            ViewModel.AddNodeAtPosition(nodeType, logicalPoint.X, logicalPoint.Y);
            AddNodeContextMenu.IsOpen = false;
        }
    }

    #endregion

    #region Node Dragging (Header Only)

    private void FileSelectButton_Click(object sender, RoutedEventArgs e)
    {
        if (sender is Button button && button.Tag is NodeViewModel nodeVm)
        {
            if (nodeVm.Name == "Import Point Cloud")
            {
                var dialog = new Microsoft.Win32.OpenFileDialog
                {
                    Filter = "Point Cloud Files|*.ply;*.pcd;*.xyz;*.csv;*.txt|All Files|*.*",
                    Title = "Select Point Cloud File"
                };

                if (dialog.ShowDialog() == true)
                {
                    var pathParam = nodeVm.Node.Parameters.FirstOrDefault(p => p.Name == "FilePath");
                    if (pathParam != null)
                    {
                        pathParam.Value = dialog.FileName;

                        if (ViewModel != null)
                        {
                            ViewModel.StatusMessage = $"Loading: {System.IO.Path.GetFileName(dialog.FileName)}";
                            _ = ViewModel.ExecuteGraphCommand.ExecuteAsync(null);
                        }
                    }
                }
            }
        }
    }

    private void NodeHeader_MouseMove(object sender, MouseEventArgs e)
    {
        if (_isDraggingNode && _draggedNode != null && e.LeftButton == MouseButtonState.Pressed)
        {
            var currentPos = e.GetPosition(NodeCanvas);
            var delta = currentPos - _mouseStartPosition;

            _draggedNode.X = _nodeStartPosition.X + delta.X / _currentZoom; // adjust for zoom
            _draggedNode.Y = _nodeStartPosition.Y + delta.Y / _currentZoom; // adjust for zoom

            ViewModel?.UpdateConnectionPositions();
            e.Handled = true;
        }
    }

    private void NodeHeader_MouseLeftButtonUp(object sender, MouseButtonEventArgs e)
    {
        if (_isDraggingNode && sender is Border header)
        {
            _isDraggingNode = false;
            _draggedNode = null;
            header.ReleaseMouseCapture();
            e.Handled = true;
        }
    }

    #endregion // Node Dragging (Header Only)

    #region Port Connection Dragging

    private void OutputPort_MouseDown(object sender, MouseButtonEventArgs e)
    {
        if (sender is Ellipse ellipse && ellipse.Tag is NodeViewModel nodeVm)
        {
            StartConnectionDrag(ellipse, nodeVm, true);
            e.Handled = true;
        }
    }

    private void InputPort_MouseDown(object sender, MouseButtonEventArgs e)
    {
        if (sender is Ellipse ellipse && ellipse.Tag is NodeViewModel nodeVm)
        {
            StartConnectionDrag(ellipse, nodeVm, false);
            e.Handled = true;
        }
    }

    private void StartConnectionDrag(Ellipse port, NodeViewModel nodeVm, bool isOutput)
    {
        _isDraggingConnection = true;
        _connectionSourceNode = nodeVm;
        _isOutputPort = isOutput;

        var portCenter = port.TranslatePoint(new System.Windows.Point(6, 6), NodeCanvas);
        _dragStartPoint = portCenter;

        TempConnectionLine.Visibility = Visibility.Visible;
        UpdateTempConnectionLine(portCenter);
        // Removed NodeCanvas.CaptureMouse to allow MouseUp to reach target ellipse
    }

    private void Port_MouseUp(object sender, MouseButtonEventArgs e)
    {
        if (_isDraggingConnection && sender is Ellipse ellipse && ellipse.Tag is NodeViewModel targetNodeVm)
        {
            // Determine if this is a valid connection
            bool isTargetInput = !_isOutputPort;
            
            // Can only connect output -> input or input -> output
            if (_connectionSourceNode != null && _connectionSourceNode != targetNodeVm)
            {
                NodeViewModel sourceNode, targetNode;
                
                if (_isOutputPort)
                {
                    // Dragging from output -> must connect to input
                    sourceNode = _connectionSourceNode;
                    targetNode = targetNodeVm;
                }
                else
                {
                    // Dragging from input -> must connect from output
                    sourceNode = targetNodeVm;
                    targetNode = _connectionSourceNode;
                }

                // Create the connection
                ViewModel?.CreateConnection(sourceNode, targetNode);
            }

            EndConnectionDrag();
            e.Handled = true;
        }
    }

    private void NodeCanvas_MouseMove(object sender, MouseEventArgs e)
    {
        if (_isDraggingConnection)
        {
            var currentPos = e.GetPosition(NodeCanvas);
            UpdateTempConnectionLine(currentPos);
        }
    }

    // NodeCanvas_MouseLeftButtonUp moved to Node Selection region

    private void TryConnectAtPoint(Point point)
    {
        var hit = VisualTreeHelper.HitTest(NodeCanvas, point);
        if (hit == null) return;

        // Walk up visual tree to find an Ellipse with a NodeViewModel Tag
        DependencyObject current = hit.VisualHit;
        while (current != null && current is not Ellipse)
        {
            current = VisualTreeHelper.GetParent(current);
        }
        if (current is Ellipse ellipse && ellipse.Tag is NodeViewModel targetNodeVm && _connectionSourceNode != null && targetNodeVm != _connectionSourceNode)
        {
            // Determine if ellipse is input or output by fill color
            var brush = ellipse.Fill as SolidColorBrush;
            bool targetIsInput = brush != null && brush.Color == Color.FromRgb(0x4C, 0xAF, 0x50); // Green
            bool targetIsOutput = brush != null && brush.Color == Color.FromRgb(0xFF, 0x98, 0x00); // Orange

            NodeViewModel sourceNode;
            NodeViewModel targetNode;
            if (_isOutputPort && targetIsInput)
            {
                sourceNode = _connectionSourceNode;
                targetNode = targetNodeVm;
            }
            else if (!_isOutputPort && targetIsOutput)
            {
                sourceNode = targetNodeVm;
                targetNode = _connectionSourceNode;
            }
            else
            {
                return; // incompatible port types
            }

            ViewModel?.CreateConnection(sourceNode, targetNode);
        }
    }

    private void UpdateTempConnectionLine(System.Windows.Point endPoint)
    {
        var geometry = new PathGeometry();
        var figure = new PathFigure { StartPoint = _dragStartPoint };

        // Create bezier curve
        var dx = endPoint.X - _dragStartPoint.X;
        var controlOffset = Math.Abs(dx) * 0.5;

        var control1 = _isOutputPort
            ? new System.Windows.Point(_dragStartPoint.X + controlOffset, _dragStartPoint.Y)
            : new System.Windows.Point(_dragStartPoint.X - controlOffset, _dragStartPoint.Y);

        var control2 = _isOutputPort
            ? new System.Windows.Point(endPoint.X - controlOffset, endPoint.Y)
            : new System.Windows.Point(endPoint.X + controlOffset, endPoint.Y);

        figure.Segments.Add(new BezierSegment(control1, control2, endPoint, true));
        geometry.Figures.Add(figure);
        TempConnectionLine.Data = geometry;
    }

    private void EndConnectionDrag()
    {
        _isDraggingConnection = false;
        _connectionSourceNode = null;
        TempConnectionLine.Visibility = Visibility.Collapsed;
        // Removed NodeCanvas.ReleaseMouseCapture
    }

    #endregion // Port Connection Dragging

    #region Connection Deletion (Double-Click)

    private void Connection_MouseLeftButtonDown(object sender, MouseButtonEventArgs e)
    {
        if (sender is Path path && path.Tag is ConnectionViewModel connVm)
        {
            var now = DateTime.Now;
            var timeSinceLastClick = (now - _lastConnectionClickTime).TotalMilliseconds;

            if (_lastClickedConnection == connVm && timeSinceLastClick < DoubleClickMs)
            {
                // Double-click detected - delete connection
                ViewModel?.DeleteConnection(connVm);
                _lastClickedConnection = null;
                _lastConnectionClickTime = DateTime.MinValue;
            }
            else
            {
                // First click
                _lastClickedConnection = connVm;
                _lastConnectionClickTime = now;
            }

            e.Handled = true;
        }
    }

    private void ParameterRow_MouseLeftButtonUp(object sender, MouseButtonEventArgs e)
    {
        if (sender is Border b && b.DataContext is VPP.Core.Interfaces.IParameter param)
        {
            // Ascend to find NodeViewModel
            DependencyObject current = b;
            NodeViewModel? nodeVm = null;
            while (current != null)
            {
                if (current is Border bd && bd.DataContext is NodeViewModel nvm)
                { nodeVm = nvm; break; }
                current = VisualTreeHelper.GetParent(current);
            }
            if (nodeVm == null) return;

            // FilePath handling for Import Point Cloud
            if (nodeVm.Name == "Import Point Cloud" && param.Name == "FilePath")
            {
                var dialog = new Microsoft.Win32.OpenFileDialog
                {
                    Filter = "Point Cloud Files|*.ply;*.pcd;*.xyz;*.csv;*.txt|All Files|*.*",
                    Title = "Select Point Cloud File"
                };
                if (dialog.ShowDialog() == true)
                {
                    param.Value = dialog.FileName;
                    ViewModel!.StatusMessage = $"Loaded: {System.IO.Path.GetFileName(dialog.FileName)}";
                    _ = ViewModel.ExecuteGraphCommand.ExecuteAsync(null);
                }
                return;
            }

            // Matrix editing for Rigid Transform node
            if (nodeVm.Name == "Rigid Transform" && param.Name == "Matrix")
            {
                var currentMatrix = param.Value is System.Numerics.Matrix4x4 m ? m : System.Numerics.Matrix4x4.Identity;
                var editor = new MatrixEditWindow(currentMatrix);
                editor.Owner = this;
                if (editor.ShowDialog() == true)
                {
                    param.Value = editor.ResultMatrix;
                    ViewModel!.StatusMessage = "Matrix updated";
                    // Optionally auto-execute graph to apply transform
                    _ = ViewModel.ExecuteGraphCommand.ExecuteAsync(null);
                }
            }
        }
    }

    #endregion

    #region ROI Drawing

    private void RoiShapeBox_Click(object sender, RoutedEventArgs e)
    {
        _currentRoiShape = "Box";
        _isDrawingRoi = false;
        _roiFirstPoint = null;
        if (ViewModel?.SelectedRoiNode?.Node != null)
        {
            var shapeParam = ViewModel.SelectedRoiNode.Node.Parameters.FirstOrDefault(p => p.Name == "Shape");
            if (shapeParam != null) shapeParam.Value = "Box";
            ViewModel.StatusMessage = "Drawing Box ROI - Click two points in 3D viewer (center, then corner)";
        }
    }

    private void RoiShapeCylinder_Click(object sender, RoutedEventArgs e)
    {
        _currentRoiShape = "Cylinder";
        _isDrawingRoi = false;
        _roiFirstPoint = null;
        if (ViewModel?.SelectedRoiNode?.Node != null)
        {
            var shapeParam = ViewModel.SelectedRoiNode.Node.Parameters.FirstOrDefault(p => p.Name == "Shape");
            if (shapeParam != null) shapeParam.Value = "Cylinder";
            ViewModel.StatusMessage = "Drawing Cylinder ROI - Click two points in 3D viewer (center, then edge point)";
        }
    }

    private void RoiShapeSphere_Click(object sender, RoutedEventArgs e)
    {
        _currentRoiShape = "Sphere";
        _isDrawingRoi = false;
        _roiFirstPoint = null;
        if (ViewModel?.SelectedRoiNode?.Node != null)
        {
            var shapeParam = ViewModel.SelectedRoiNode.Node.Parameters.FirstOrDefault(p => p.Name == "Shape");
            if (shapeParam != null) shapeParam.Value = "Sphere";
            ViewModel.StatusMessage = "Drawing Sphere ROI - Click two points in 3D viewer (center, then surface point)";
        }
    }

    private void Viewport3D_MouseLeftButtonDown(object sender, MouseButtonEventArgs e)
    {
        if (ViewModel == null || !ViewModel.IsRoiDrawingMode || ViewModel.SelectedRoiNode == null)
            return;

        var position = e.GetPosition(Viewport3D);
        var hitPoint = GetHitPoint(position);

        if (hitPoint == null)
        {
            ViewModel.StatusMessage = "Click on a point in the point cloud";
            return;
        }

        if (!_roiFirstPoint.HasValue)
        {
            // First click - set center
            _roiFirstPoint = hitPoint.Value;
            _isDrawingRoi = true;
            ViewModel.StatusMessage = $"Center set at ({hitPoint.Value.X:F2}, {hitPoint.Value.Y:F2}, {hitPoint.Value.Z:F2}) - Click second point";
        }
        else
        {
            // Second click - set size/radius
            var center = _roiFirstPoint.Value;
            var secondPoint = hitPoint.Value;

            UpdateRoiParameters(center, secondPoint);

            _isDrawingRoi = false;
            _roiFirstPoint = null;
            ViewModel.StatusMessage = "ROI updated - Select another shape or background to exit drawing mode";

            e.Handled = true;
        }
    }

    private System.Numerics.Vector3? GetHitPoint(System.Windows.Point mousePosition)
    {
        if (ViewModel?.PointCloudGeometry?.Positions == null || ViewModel.PointCloudGeometry.Positions.Count == 0)
            return null;

        // Use camera ray casting to find nearest point
        var viewport = Viewport3D;
        var camera = ViewModel.Camera;

        if (camera is PerspectiveCamera perspCam)
        {
            // Convert 2D screen point to 3D world ray
            var ray = GetRay(perspCam, mousePosition, viewport.ActualWidth, viewport.ActualHeight);

            // Find closest point cloud point to ray
            var positions = ViewModel.PointCloudGeometry.Positions;
            float minDist = float.MaxValue;
            System.Numerics.Vector3? closestPoint = null;

            foreach (var p in positions)
            {
                var point = new System.Numerics.Vector3(p.X, p.Y, p.Z);
                var dist = DistanceToRay(point, ray.origin, ray.direction);
                if (dist < minDist)
                {
                    minDist = dist;
                    closestPoint = point;
                }
            }

            // Only return if reasonably close
            if (minDist < 50f)
                return closestPoint;
        }

        return null;
    }

    private (System.Numerics.Vector3 origin, System.Numerics.Vector3 direction) GetRay(PerspectiveCamera camera, System.Windows.Point screenPoint, double width, double height)
    {
        var origin = new System.Numerics.Vector3(
            (float)camera.Position.X,
            (float)camera.Position.Y,
            (float)camera.Position.Z);

        // Simple approximation - convert screen point to world direction
        var lookDir = new System.Numerics.Vector3(
            (float)camera.LookDirection.X,
            (float)camera.LookDirection.Y,
            (float)camera.LookDirection.Z);

        var upDir = new System.Numerics.Vector3(
            (float)camera.UpDirection.X,
            (float)camera.UpDirection.Y,
            (float)camera.UpDirection.Z);

        var rightDir = System.Numerics.Vector3.Cross(lookDir, upDir);
        rightDir = System.Numerics.Vector3.Normalize(rightDir);
        upDir = System.Numerics.Vector3.Cross(rightDir, lookDir);
        upDir = System.Numerics.Vector3.Normalize(upDir);

        var fov = camera.FieldOfView * Math.PI / 180.0;
        var aspectRatio = width / height;

        var dx = (float)((screenPoint.X / width - 0.5) * 2 * Math.Tan(fov / 2) * aspectRatio);
        var dy = (float)((0.5 - screenPoint.Y / height) * 2 * Math.Tan(fov / 2));

        var direction = lookDir + rightDir * dx + upDir * dy;
        direction = System.Numerics.Vector3.Normalize(direction);

        return (origin, direction);
    }

    private float DistanceToRay(System.Numerics.Vector3 point, System.Numerics.Vector3 rayOrigin, System.Numerics.Vector3 rayDirection)
    {
        var toPoint = point - rayOrigin;
        var projection = System.Numerics.Vector3.Dot(toPoint, rayDirection);
        var closestPointOnRay = rayOrigin + rayDirection * projection;
        return System.Numerics.Vector3.Distance(point, closestPointOnRay);
    }

    private void UpdateRoiParameters(System.Numerics.Vector3 center, System.Numerics.Vector3 secondPoint)
    {
        if (ViewModel?.SelectedRoiNode?.Node == null) return;

        var node = ViewModel.SelectedRoiNode.Node;

        // Set center
        var centerXParam = node.Parameters.FirstOrDefault(p => p.Name == "CenterX");
        var centerYParam = node.Parameters.FirstOrDefault(p => p.Name == "CenterY");
        var centerZParam = node.Parameters.FirstOrDefault(p => p.Name == "CenterZ");
        if (centerXParam != null) centerXParam.Value = center.X;
        if (centerYParam != null) centerYParam.Value = center.Y;
        if (centerZParam != null) centerZParam.Value = center.Z;

        if (_currentRoiShape == "Box")
        {
            // Calculate box size (center to corner * 2)
            var size = System.Numerics.Vector3.Abs(secondPoint - center) * 2;
            var sizeXParam = node.Parameters.FirstOrDefault(p => p.Name == "SizeX");
            var sizeYParam = node.Parameters.FirstOrDefault(p => p.Name == "SizeY");
            var sizeZParam = node.Parameters.FirstOrDefault(p => p.Name == "SizeZ");
            if (sizeXParam != null) sizeXParam.Value = size.X;
            if (sizeYParam != null) sizeYParam.Value = size.Y;
            if (sizeZParam != null) sizeZParam.Value = size.Z;
        }
        else if (_currentRoiShape == "Cylinder" || _currentRoiShape == "Sphere")
        {
            // Calculate radius
            float radius;
            if (_currentRoiShape == "Cylinder")
            {
                // Radius in XZ plane
                var dx = secondPoint.X - center.X;
                var dz = secondPoint.Z - center.Z;
                radius = MathF.Sqrt(dx * dx + dz * dz);

                // Height from Y difference
                var height = MathF.Abs(secondPoint.Y - center.Y) * 2;
                var sizeYParam = node.Parameters.FirstOrDefault(p => p.Name == "SizeY");
                if (sizeYParam != null) sizeYParam.Value = Math.Max(height, 1f);
            }
            else
            {
                // Sphere - 3D distance
                radius = System.Numerics.Vector3.Distance(center, secondPoint);
            }

            var radiusParam = node.Parameters.FirstOrDefault(p => p.Name == "Radius");
            if (radiusParam != null) radiusParam.Value = Math.Max(radius, 0.1f);
        }

        // Update visualization
        ViewModel.UpdateRoiFromParameters(ViewModel.SelectedRoiNode);
    }

    #endregion

    #region Node Selection

    private void NodeHeader_MouseLeftButtonDown(object sender, MouseButtonEventArgs e)
    {
        if (sender is Border header && header.DataContext is NodeViewModel nodeVm)
        {
            // Double-click: delete node
            if (e.ClickCount == 2)
            {
                ViewModel?.DeleteNode(nodeVm);
                e.Handled = true;
                return;
            }

            // Single click: select node
            ViewModel?.SelectNode(nodeVm);

            // Don't start dragging if clicking a button
            if (e.OriginalSource is Button)
            {
                e.Handled = true;
                return;
            }

            // Start dragging the node
            _isDraggingNode = true;
            _draggedNode = nodeVm;
            _nodeStartPosition = new System.Windows.Point(nodeVm.X, nodeVm.Y);
            _mouseStartPosition = e.GetPosition(NodeCanvas);
            header.CaptureMouse();
            e.Handled = true;
        }
    }

    private void NodeCanvas_MouseLeftButtonUp(object sender, MouseButtonEventArgs e)
    {
        if (_isDraggingConnection)
        {
            // Fallback: if user released over canvas (target ellipse didn't get MouseUp) perform hit test
            var releasePoint = e.GetPosition(NodeCanvas);
            TryConnectAtPoint(releasePoint);
            EndConnectionDrag();
        }
        else if (!_isDraggingNode)
        {
            // Click on background - deselect all nodes
            ViewModel?.SelectNode(null);
        }
    }

    #endregion
}
