using System.Diagnostics;
using VPP.Core.Interfaces;
using VPP.Core.Attributes;
using System.Reflection;
using System.ComponentModel;

namespace VPP.Core.Models;

/// <summary>
/// Base class for all nodes in the new simplified architecture.
/// Nodes use Parameters (editable in UI) and share data via ExecutionContext.
/// </summary>
public abstract class NodeBase : INode
{
    public string Id { get; } = Guid.NewGuid().ToString();
    public virtual string Name => GetType().GetCustomAttribute<NodeInfoAttribute>()?.Name ?? GetType().Name;
    public virtual string Category => GetType().GetCustomAttribute<NodeInfoAttribute>()?.Category ?? "General";
    public virtual string Description => GetType().GetCustomAttribute<NodeInfoAttribute>()?.Description ?? "";

    private readonly List<Parameter> _parameters = new();
    public IReadOnlyList<IParameter> Parameters => _parameters;

    private readonly List<IPort> _inputPorts = new();
    private readonly List<IPort> _outputPorts = new();

    public double X { get; set; }
    public double Y { get; set; }

    /// <summary>
    /// Add a parameter that can be edited directly in the node UI.
    /// </summary>
    protected Parameter AddParameter<T>(string name, T? defaultValue = default, bool required = false, string? displayName = null, string? description = null)
    {
        var param = new Parameter(name, typeof(T), defaultValue, required, displayName, description);
        _parameters.Add(param);
        return param;
    }

    /// <summary>
    /// Get parameter value by name.
    /// </summary>
    protected T? GetParameter<T>(string name) =>
        _parameters.FirstOrDefault(p => p.Name == name)?.Value is T val ? val : default;

    /// <summary>
    /// Set parameter value by name.
    /// </summary>
    protected void SetParameter<T>(string name, T value)
    {
        var param = _parameters.FirstOrDefault(p => p.Name == name);
        if (param != null) param.Value = value;
    }

    protected void AddInputPort<T>(string name, string description, bool required = true, object? defaultValue = default)
    {
        _inputPorts.Add(new Port(name, typeof(T), PortDirection.Input, required, defaultValue));
    }

    protected void AddOutputPort<T>(string name, string description)
    {
        _outputPorts.Add(new Port(name, typeof(T), PortDirection.Output, false, default(T)));
    }

    protected T? GetInputValue<T>(string name)
    {
        var port = _inputPorts.FirstOrDefault(p => p.Name == name);
        if (port?.Value is T val)
        {
            return val;
        }
        return default;
    }

    protected void SetOutputValue<T>(string name, T value)
    {
        var port = _outputPorts.FirstOrDefault(p => p.Name == name);
        if (port != null)
        {
            port.Value = value;
        }
    }

    /// <summary>
    /// Execute the node with shared execution context.
    /// </summary>
    public async Task<NodeResult> ExecuteAsync(ExecutionContext context, CancellationToken cancellationToken = default)
    {
        var sw = Stopwatch.StartNew();
        try
        {
            if (!Validate(out var errors))
                return NodeResult.Fail(string.Join("; ", errors));

            await ExecuteCoreAsync(context, cancellationToken);

            return new NodeResult
            {
                Success = true,
                ExecutionTime = sw.Elapsed
            };
        }
        catch (Exception ex)
        {
            return new NodeResult
            {
                Success = false,
                ErrorMessage = ex.Message,
                ExecutionTime = sw.Elapsed
            };
        }
    }

    /// <summary>
    /// Core execution logic - implemented by derived classes.
    /// Access shared data via context, read/write parameters directly.
    /// </summary>
    protected abstract Task ExecuteCoreAsync(ExecutionContext context, CancellationToken cancellationToken);

    public virtual bool Validate(out string[] errors)
    {
        var errs = new List<string>();
        foreach (var param in _parameters.Where(p => p.IsRequired && p.Value == null))
            errs.Add($"Required parameter '{param.DisplayName ?? param.Name}' has no value");
        errors = errs.ToArray();
        return errs.Count == 0;
    }

    public void Reset()
    {
        foreach (var param in _parameters)
            param.Value = param.DefaultValue;
    }

    public IReadOnlyList<IPort> InputPorts => _inputPorts;

    public IReadOnlyList<IPort> OutputPorts => _outputPorts;
}

/// <summary>
/// Parameter class for node configuration.
/// </summary>
public class Parameter : IParameter, INotifyPropertyChanged
{
    public string Name { get; }
    public Type Type { get; }

    private object? _value;
    public object? Value
    {
        get => _value;
        set
        {
            if (!Equals(_value, value))
            {
                _value = value;
                PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(nameof(Value)));
            }
        }
    }

    public object? DefaultValue { get; }
    public bool IsRequired { get; }
    public string? DisplayName { get; }
    public string? Description { get; }

    public event PropertyChangedEventHandler? PropertyChanged;

    public Parameter(string name, Type type, object? defaultValue, bool required, string? displayName, string? description)
    {
        Name = name;
        Type = type;
        DefaultValue = defaultValue;
        _value = defaultValue;
        IsRequired = required;
        DisplayName = displayName ?? name;
        Description = description;
    }
}

public class Port : IPort
{
    public string Id { get; } = Guid.NewGuid().ToString();
    public string Name { get; }
    public Type DataType { get; }
    public PortDirection Direction { get; }
    public bool IsConnected { get; set; }
    public object? Value { get; set; }
    public object? DefaultValue { get; }
    public bool IsRequired { get; }

    public Port(string name, Type dataType, PortDirection direction, bool required, object? defaultValue)
    {
        Name = name;
        DataType = dataType;
        Direction = direction;
        IsRequired = required;
        DefaultValue = defaultValue;
        Value = defaultValue;
    }
}
