using System.Collections.ObjectModel;
using System.Windows.Media;
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using Microsoft.Win32;
using VPP.Core.Engine;
using VPP.Core.Interfaces;
using VPP.Core.Models;
using VPP.Core.Services;
using VPP.Plugins.PointCloud;
using VPP.Plugins.PointCloud.Models;
using HelixToolkit.Wpf.SharpDX;
using SharpDX;
using VPP.App.Rendering;
using Media3D = System.Windows.Media.Media3D;
using Color = System.Windows.Media.Color;

namespace VPP.App.ViewModels;

public partial class MainViewModel : ObservableObject
{
    private readonly PluginService _pluginService;
    private readonly ExecutionEngine _executionEngine;
    private VPP.Core.Models.ExecutionContext? _lastExecutionContext;

    [ObservableProperty] private NodeGraph _graph = new();
    [ObservableProperty] private ObservableCollection<NodeViewModel> _nodes = new();
    [ObservableProperty] private ObservableCollection<ConnectionViewModel> _connections = new();
    [ObservableProperty] private ObservableCollection<string> _availableNodes = new();
    [ObservableProperty] private string _selectedNodeType = "";
    [ObservableProperty] private NodeViewModel? _selectedNode;
    [ObservableProperty] private string _statusMessage = "Ready";
    [ObservableProperty] private bool _isExecuting;

    // GPU-accelerated SharpDX properties
    [ObservableProperty] private PointGeometry3D? _pointCloudGeometry;
    [ObservableProperty] private Color _pointCloudColor = Colors.LightGray; // Darker default for visibility
    [ObservableProperty] private double _pointSize = 2.0;
    [ObservableProperty] private Camera _camera;
    [ObservableProperty] private IEffectsManager _effectsManager;

    // LOD settings
    private const int MAX_POINTS_FOR_FULL_RENDER = 10_000_000; // 10M points max
    private const int LOD_THRESHOLD_HIGH = 2_000_000; // 2M points - high quality
    private const int LOD_THRESHOLD_MEDIUM = 5_000_000; // 5M points - medium quality

    [ObservableProperty] private string _inspectionResult = "";
    [ObservableProperty] private bool _inspectionPass;
    [ObservableProperty] private double _detectedRadius;
    [ObservableProperty] private Media3D.Point3D _detectedCenter;
    [ObservableProperty] private string _nodeSearchText = "";
    [ObservableProperty] private ObservableCollection<string> _filteredNodes = new();
    [ObservableProperty] private LineGeometry3D? _originAxesGeometry; // axes lines (legacy combined)
    [ObservableProperty] private Color _originXColor = Colors.Red;
    [ObservableProperty] private Color _originYColor = Colors.Green;
    [ObservableProperty] private Color _originZColor = Colors.Blue;
    // New per-axis geometries for colored rendering
    [ObservableProperty] private LineGeometry3D? _originXGeometry;
    [ObservableProperty] private LineGeometry3D? _originYGeometry;
    [ObservableProperty] private LineGeometry3D? _originZGeometry;

    // ROI Drawing Mode
    [ObservableProperty] private bool _isRoiDrawingMode;
    [ObservableProperty] private NodeViewModel? _selectedRoiNode;
    [ObservableProperty] private LineGeometry3D? _roiWireframeGeometry;
    [ObservableProperty] private Color _roiWireframeColor = Colors.Yellow;
    [ObservableProperty] private MeshGeometry3D? _roiCenterPointGeometry;
    [ObservableProperty] private Color _roiCenterPointColor = Colors.Red;

    // ROI Filter toggle (visible only when ROI Filter node is selected)
    [ObservableProperty] private bool _isRoiFilterToggleVisible;
    [ObservableProperty] private bool _isRoiFilterOn;
    private NodeViewModel? _selectedRoiFilterNode;

    // Center point sphere radius (smaller for less visual clutter)
    private const float RoiCenterSphereRadius = 0.1f; // reduced from 0.5f

    public MainViewModel()
    {
        _pluginService = new PluginService();
        _executionEngine = new ExecutionEngine();
        _effectsManager = new DefaultEffectsManager();
        _camera = new PerspectiveCamera
        {
            Position = new Media3D.Point3D(0, 0, 300),
            LookDirection = new Media3D.Vector3D(0, 0, -1),
            UpDirection = new Media3D.Vector3D(0, 1, 0),
            FieldOfView = 45,
            NearPlaneDistance = 0.1,
            FarPlaneDistance = 100000 // Large far plane to prevent disappearing on zoom out
        };

        // Load built-in plugins
        _pluginService.LoadFromAssembly(typeof(PointCloudPlugin).Assembly);

        // Populate available nodes
        foreach (var (name, category, _) in _pluginService.GetAvailableNodes())
        {
            AvailableNodes.Add($"{category}/{name}");
        }

        _executionEngine.NodeExecuting += (s, e) =>
            StatusMessage = $"Executing: {e.Node.Name}";
        _executionEngine.NodeExecuted += (s, e) =>
        {
            StatusMessage = e.Result?.Success == true ? $"Completed: {e.Node.Name}" : $"Failed: {e.Node.Name}";
            // Real-time visualization update after each node execution
            UpdateVisualization();
        };
    }

    partial void OnIsRoiFilterOnChanged(bool value)
    {
        // Only affect visualization while the ROI Filter node is selected
        if (_selectedRoiFilterNode != null)
        {
            UpdateVisualization();
        }
    }

    [RelayCommand]
    private void AddNode()
    {
        if (string.IsNullOrEmpty(SelectedNodeType)) return;

        var nodeName = SelectedNodeType.Split('/').Last();
        var node = _pluginService.CreateNode(nodeName);
        if (node == null) return;

        if (node is NodeBase nb)
        {
            nb.X = 100 + Nodes.Count * 200;
            nb.Y = 100;
        }

        Graph.AddNode(node);
        Nodes.Add(new NodeViewModel(node));
        StatusMessage = $"Added node: {node.Name}";
    }

    [RelayCommand]
    private async Task ExecuteGraph()
    {
        if (IsExecuting) return;
        IsExecuting = true;
        StatusMessage = "Executing graph...";

        try
        {
            var result = await _executionEngine.ExecuteAsync(Graph);

            if (result.Success)
            {
                _lastExecutionContext = result.Context;
                StatusMessage = "Execution completed successfully";
                UpdateVisualization();
            }
            else
            {
                var failedNode = result.NodeResults.FirstOrDefault(r => !r.Value.Success);
                StatusMessage = $"Execution failed: {failedNode.Value?.ErrorMessage}";
            }
        }
        catch (Exception ex)
        {
            StatusMessage = $"Error: {ex.Message}";
        }
        finally
        {
            IsExecuting = false;
        }
    }

    [RelayCommand]
    private async Task LoadPointCloud()
    {
        var dialog = new OpenFileDialog
        {
            Filter = "Point Cloud Files|*.ply;*.pcd;*.xyz;*.csv;*.txt|All Files|*.*",
            Title = "Select Point Cloud File"
        };

        if (dialog.ShowDialog() == true)
        {
            // Find import node and set file path parameter
            var importNode = Graph.Nodes.FirstOrDefault(n => n.Name == "Import Point Cloud");
            if (importNode != null)
            {
                var pathParam = importNode.Parameters.FirstOrDefault(p => p.Name == "FilePath");
                if (pathParam != null)
                    pathParam.Value = dialog.FileName;
                StatusMessage = $"Loaded: {System.IO.Path.GetFileName(dialog.FileName)}";

                // Auto-execute to display the point cloud
                await ExecuteGraph();
            }
            else
            {
                StatusMessage = "Add 'Import Point Cloud' node first";
            }
        }
    }

    [RelayCommand]
    private void CreateDefaultWorkflow()
    {
        // Clear existing
        Graph = new NodeGraph();
        Nodes.Clear();
        Connections.Clear();

        // Create workflow: Import -> ROI -> Circle Detection -> Inspection
        var importNode = _pluginService.CreateNode("Import Point Cloud") as NodeBase;
        var roiDrawNode = _pluginService.CreateNode("ROI Draw") as NodeBase;
        var roiFilterNode = _pluginService.CreateNode("ROI Filter") as NodeBase;
        var circleNode = _pluginService.CreateNode("Circle Detection") as NodeBase;
        var inspectNode = _pluginService.CreateNode("Spec Inspection") as NodeBase;

        if (importNode == null || roiDrawNode == null || roiFilterNode == null ||
            circleNode == null || inspectNode == null) return;

        // Position nodes
        importNode.X = 50; importNode.Y = 150;
        roiDrawNode.X = 50; roiDrawNode.Y = 350;
        roiFilterNode.X = 300; roiFilterNode.Y = 200;
        circleNode.X = 550; circleNode.Y = 200;
        inspectNode.X = 800; inspectNode.Y = 200;

        // Set default parameter values
        roiDrawNode.Parameters.First(p => p.Name == "SizeX").Value = 100f;
        roiDrawNode.Parameters.First(p => p.Name == "SizeY").Value = 100f;
        roiDrawNode.Parameters.First(p => p.Name == "SizeZ").Value = 50f;

        inspectNode.Parameters.First(p => p.Name == "RadiusMin").Value = 5f;
        inspectNode.Parameters.First(p => p.Name == "RadiusMax").Value = 15f;

        // Add to graph
        Graph.AddNode(importNode);
        Graph.AddNode(roiDrawNode);
        Graph.AddNode(roiFilterNode);
        Graph.AddNode(circleNode);
        Graph.AddNode(inspectNode);

        // Connect nodes (simple execution order)
        Graph.Connect(importNode, roiFilterNode);
        Graph.Connect(importNode, circleNode);
        Graph.Connect(roiFilterNode, circleNode);
        Graph.Connect(circleNode, inspectNode);

        // Create view models
        var importNodeVm = new NodeViewModel(importNode);
        var roiDrawNodeVm = new NodeViewModel(roiDrawNode);
        var roiFilterNodeVm = new NodeViewModel(roiFilterNode);
        var circleNodeVm = new NodeViewModel(circleNode);
        var inspectNodeVm = new NodeViewModel(inspectNode);

        Nodes.Add(importNodeVm);
        Nodes.Add(roiDrawNodeVm);
        Nodes.Add(roiFilterNodeVm);
        Nodes.Add(circleNodeVm);
        Nodes.Add(inspectNodeVm);

        // Create connection view models with proper references
        var nodeVmMap = Nodes.ToDictionary(n => n.Node.Id, n => n);
        foreach (var conn in Graph.Connections)
        {
            var sourceVm = nodeVmMap[conn.SourceNodeId];
            var targetVm = nodeVmMap[conn.TargetNodeId];
            Connections.Add(new ConnectionViewModel(conn, sourceVm, targetVm));
        }

        StatusMessage = "Created default workflow";
    }

    private void UpdateVisualization()
    {
        if (_lastExecutionContext == null) return;

        int totalOriginalPoints = 0;
        var clouds = new List<PointCloudData>();

        // All Import and Transform nodes
        var importNodes = Graph.Nodes.Where(n => n.Name == "Import Point Cloud").ToList();
        var transformNodes = Graph.Nodes.Where(n => n.Name == "Rigid Transform").ToList();

        // Find all import nodes that feed into any transform (directly or indirectly)
        var transformedImportIds = new HashSet<string>();
        foreach (var t in transformNodes)
        {
            foreach (var upId in GetUpstreamImportIds(t.Id))
                transformedImportIds.Add(upId);
        }

        // Add untransformed import clouds that are NOT part of any transform path
        foreach (var importNode in importNodes)
        {
            if (!transformedImportIds.Contains(importNode.Id))
            {
                var nodeCloud = _lastExecutionContext.Get<PointCloudData>($"{VPP.Core.Models.ExecutionContext.PointCloudKey}_{importNode.Id}");
                if (nodeCloud != null && nodeCloud.Points.Count > 0)
                {
                    clouds.Add(nodeCloud);
                    totalOriginalPoints += nodeCloud.Points.Count;
                }
            }
        }

        // Add all transformed clouds
        foreach (var t in transformNodes)
        {
            var transformedCloud = _lastExecutionContext.Get<PointCloudData>($"TransformedCloud_{t.Id}");
            if (transformedCloud != null && transformedCloud.Points.Count > 0)
            {
                clouds.Add(transformedCloud);
                totalOriginalPoints += transformedCloud.Points.Count;
            }
        }

        // Fallback: only raw global cloud
        if (clouds.Count == 0)
        {
            var globalCloud = _lastExecutionContext.Get<PointCloudData>(VPP.Core.Models.ExecutionContext.PointCloudKey);
            if (globalCloud != null && globalCloud.Points.Count > 0)
            {
                clouds.Add(globalCloud);
                totalOriginalPoints = globalCloud.Points.Count;
            }
        }

        // Viewer-only ROI filter when ROI Filter node is selected and toggle is ON
        if (_selectedRoiFilterNode != null && IsRoiFilterOn)
        {
            var roi = BuildRoiFromConnectedDrawNode(_selectedRoiFilterNode);
            if (roi != null)
            {
                var filteredClouds = new List<PointCloudData>(clouds.Count);
                foreach (var cloud in clouds)
                    filteredClouds.Add(FilterCloudByRoi(cloud, roi));
                clouds = filteredClouds;
                totalOriginalPoints = clouds.Sum(c => c.Points.Count);
            }
        }

        if (clouds.Count == 0)
        {
            StatusMessage = "No points to display";
            return;
        }

        try
        {
            PointGeometry3D geometry;
            int renderedPoints;
            string lodInfo;
            if (clouds.Count == 1)
                (geometry, renderedPoints, lodInfo) = GpuPointCloudRenderer.CreateGeometry(clouds[0], enableLod: true);
            else
                (geometry, renderedPoints, lodInfo) = GpuPointCloudRenderer.CreateGeometryFromMultiple(clouds);

            PointCloudGeometry = geometry;
            FitCameraToPointCloud();

            var memoryMb = GpuPointCloudRenderer.EstimateMemoryUsage(renderedPoints, geometry.Colors != null) / (1024.0 * 1024.0);
            StatusMessage = $"Displaying {renderedPoints:N0}/{totalOriginalPoints:N0} points ({clouds.Count} cloud(s)) | {lodInfo} | GPU Memory: ~{memoryMb:F1} MB";
        }
        catch (Exception ex)
        {
            StatusMessage = $"Error rendering point clouds: {ex.Message}";
            return;
        }

        CreateOriginAxes();
        UpdateInspectionResults();
    }

    // Collect upstream Import Point Cloud node IDs for a given node id
    private IEnumerable<string> GetUpstreamImportIds(string nodeId)
    {
        var result = new HashSet<string>();
        var visited = new HashSet<string>();
        void Dfs(string targetId)
        {
            if (!visited.Add(targetId)) return;
            foreach (var conn in Graph.Connections.Where(c => c.TargetNodeId == targetId))
            {
                var source = Graph.Nodes.FirstOrDefault(n => n.Id == conn.SourceNodeId);
                if (source == null) continue;
                if (source.Name == "Import Point Cloud")
                {
                    result.Add(source.Id);
                }
                else
                {
                    Dfs(source.Id);
                }
            }
        }
        Dfs(nodeId);
        return result;
    }

    private ROI3D? BuildRoiFromConnectedDrawNode(NodeViewModel roiFilterNodeVm)
    {
        // Find an incoming connection from a ROI Draw node
        var incoming = Graph.Connections.Where(c => c.TargetNodeId == roiFilterNodeVm.Node.Id)
                                        .Select(c => Graph.Nodes.FirstOrDefault(n => n.Id == c.SourceNodeId))
                                        .FirstOrDefault(n => n != null && n.Name == "ROI Draw");
        if (incoming == null) return null;

        string shapeStr = GetParameterValue<string>(incoming, "Shape") ?? "Box";
        var shape = shapeStr.ToLower() switch
        {
            "cylinder" => ROIShape.Cylinder,
            "sphere" => ROIShape.Sphere,
            _ => ROIShape.Box
        };

        var center = new System.Numerics.Vector3(
            GetParameterValue<float>(incoming, "CenterX"),
            GetParameterValue<float>(incoming, "CenterY"),
            GetParameterValue<float>(incoming, "CenterZ"));

        var size = new System.Numerics.Vector3(
            GetParameterValue<float>(incoming, "SizeX"),
            GetParameterValue<float>(incoming, "SizeY"),
            GetParameterValue<float>(incoming, "SizeZ"));

        var radius = GetParameterValue<float>(incoming, "Radius");

        return new ROI3D
        {
            Center = center,
            Size = size,
            Radius = radius,
            Shape = shape
        };
    }

    private PointCloudData FilterCloudByRoi(PointCloudData cloud, ROI3D roi)
    {
        var result = new PointCloudData();
        for (int i = 0; i < cloud.Points.Count; i++)
        {
            var p = cloud.Points[i];
            if (IsInROI(p, roi))
            {
                result.Points.Add(p);
                if (cloud.Colors != null && i < cloud.Colors.Count)
                {
                    result.Colors ??= new List<System.Numerics.Vector3>();
                    result.Colors.Add(cloud.Colors[i]);
                }
                if (cloud.Normals != null && i < cloud.Normals.Count)
                {
                    result.Normals ??= new List<System.Numerics.Vector3>();
                    result.Normals.Add(cloud.Normals[i]);
                }
            }
        }
        result.ComputeBoundingBox();
        return result;
    }

    private bool IsInROI(System.Numerics.Vector3 point, ROI3D roi)
    {
        var diff = point - roi.Center;
        return roi.Shape switch
        {
            ROIShape.Box =>
                Math.Abs(diff.X) <= roi.Size.X / 2 &&
                Math.Abs(diff.Y) <= roi.Size.Y / 2 &&
                Math.Abs(diff.Z) <= roi.Size.Z / 2,
            ROIShape.Cylinder =>
                Math.Sqrt(diff.X * diff.X + diff.Z * diff.Z) <= roi.Radius &&
                Math.Abs(diff.Y) <= roi.Size.Y / 2,
            ROIShape.Sphere =>
                diff.Length() <= roi.Radius,
            _ => false
        };
    }

    private void CreateOriginAxes()
    {
        float axisLength = 50f;
        if (PointCloudGeometry?.Positions != null && PointCloudGeometry.Positions.Count > 0)
        {
            var min = new Vector3(float.MaxValue);
            var max = new Vector3(float.MinValue);
            foreach (var p in PointCloudGeometry.Positions)
            {
                min = Vector3.Min(min, p);
                max = Vector3.Max(max, p);
            }
            var size = max - min;
            axisLength = Math.Max(10f, Math.Min((size.X + size.Y + size.Z) / 30f, 500f));
        }

        // Legacy combined geometry (keep for backward compatibility if referenced elsewhere)
        var positionsCombined = new Vector3Collection
        {
            new Vector3(0,0,0), new Vector3(axisLength,0,0),
            new Vector3(0,0,0), new Vector3(0,axisLength,0),
            new Vector3(0,0,0), new Vector3(0,0,axisLength)
        };
        var colorsCombined = new Color4Collection
        {
            new Color4(1,0,0,1), new Color4(1,0,0,1),
            new Color4(0,1,0,1), new Color4(0,1,0,1),
            new Color4(0,0,1,1), new Color4(0,0,1,1)
        };
        OriginAxesGeometry = new LineGeometry3D { Positions = positionsCombined, Colors = colorsCombined, Indices = new IntCollection {0,1,2,3,4,5} };

        // Separate geometries for X, Y, Z axes
        OriginXGeometry = new LineGeometry3D
        {
            Positions = new Vector3Collection { new Vector3(0,0,0), new Vector3(axisLength,0,0) },
            Indices = new IntCollection {0,1}
        };
        OriginYGeometry = new LineGeometry3D
        {
            Positions = new Vector3Collection { new Vector3(0,0,0), new Vector3(0,axisLength,0) },
            Indices = new IntCollection {0,1}
        };
        OriginZGeometry = new LineGeometry3D
        {
            Positions = new Vector3Collection { new Vector3(0,0,0), new Vector3(0,0,axisLength) },
            Indices = new IntCollection {0,1}
        };
    }

    private void FitCameraToPointCloud()
    {
        if (PointCloudGeometry?.Positions == null || PointCloudGeometry.Positions.Count == 0 || Camera == null)
            return;

        var positions = PointCloudGeometry.Positions;
        var min = new Vector3(float.MaxValue, float.MaxValue, float.MaxValue);
        var max = new Vector3(float.MinValue, float.MinValue, float.MinValue);
        foreach (var p in positions)
        {
            min = Vector3.Min(min, p);
            max = Vector3.Max(max, p);
        }
        var center = (min + max) * 0.5f;
        var extents = max - min;
        float radius = extents.Length() * 0.5f;
        if (radius <= 0) radius = 1f;

        const double farPlaneBufferFactor = 10.0; // Keep far plane comfortably beyond scene

        if (Camera is PerspectiveCamera pc)
        {
            double fovRad = pc.FieldOfView * Math.PI / 180.0;
            double distance = radius / Math.Sin(fovRad / 2.0);
            distance *= 1.2; // margin
            var position = new Media3D.Point3D(center.X, center.Y, center.Z + distance);
            var lookDir = new Media3D.Vector3D(center.X - position.X, center.Y - position.Y, center.Z - position.Z);
            pc.Position = position;
            pc.LookDirection = lookDir;
            pc.UpDirection = new Media3D.Vector3D(0, 1, 0);
            pc.NearPlaneDistance = 0.1; // keep stable near plane
            var desiredFar = distance + radius * farPlaneBufferFactor;
            if (desiredFar > pc.FarPlaneDistance)
                pc.FarPlaneDistance = desiredFar; // only grow, never shrink
        }
        else if (Camera is OrthographicCamera oc)
        {
            double distance = radius * 2.5;
            var position = new Media3D.Point3D(center.X, center.Y, center.Z + distance);
            var lookDir = new Media3D.Vector3D(center.X - position.X, center.Y - position.Y, center.Z - position.Z);
            oc.Position = position;
            oc.LookDirection = lookDir;
            oc.UpDirection = new Media3D.Vector3D(0, 1, 0);
            oc.Width = radius * 2.5; // ensure whole cloud fits
            oc.NearPlaneDistance = 0.1;
            var desiredFar = distance + radius * farPlaneBufferFactor;
            if (desiredFar > oc.FarPlaneDistance)
                oc.FarPlaneDistance = desiredFar;
        }
    }

    private void UpdateInspectionResults()
    {
        if (_lastExecutionContext == null) return;

        if (_lastExecutionContext.TryGet<InspectionResult>("InspectionResult", out var inspectionResult))
        {
            InspectionPass = inspectionResult.Pass;
            InspectionResult = inspectionResult.Message;
        }

        var circle = _lastExecutionContext.Get<CircleDetectionResult>(VPP.Core.Models.ExecutionContext.CircleResultKey);
        if (circle != null)
        {
            DetectedRadius = circle.Radius;
            DetectedCenter = new Media3D.Point3D(circle.Center.X, circle.Center.Y, circle.Center.Z);
        }
    }

    public void UpdateFilteredNodes()
    {
        FilteredNodes.Clear();
        var search = NodeSearchText?.ToLower() ?? "";

        foreach (var node in AvailableNodes)
        {
            if (string.IsNullOrEmpty(search) || node.ToLower().Contains(search))
            {
                FilteredNodes.Add(node);
            }
        }
    }

    public void AddNodeAtPosition(string nodeType, double x, double y)
    {
        var nodeName = nodeType.Split('/').Last();
        var node = _pluginService.CreateNode(nodeName);
        if (node == null) return;

        if (node is NodeBase nb)
        {
            nb.X = x;
            nb.Y = y;
        }

        Graph.AddNode(node);
        Nodes.Add(new NodeViewModel(node));
        StatusMessage = $"Added node: {node.Name}";
    }

    public void CreateConnection(NodeViewModel sourceNodeVm, NodeViewModel targetNodeVm)
    {
        var sourceNode = sourceNodeVm.Node;
        var targetNode = targetNodeVm.Node;

        if (sourceNode == null || targetNode == null) return;

        // Check if connection already exists
        var existingConnection = Graph.Connections.FirstOrDefault(c =>
            c.SourceNodeId == sourceNode.Id && c.TargetNodeId == targetNode.Id);

        if (existingConnection != null) return;

        // Create simple execution order connection
        if (!Graph.Connect(sourceNode, targetNode)) return;

        // Create visual connection
        var connection = Graph.Connections.Last();
        var connVm = new ConnectionViewModel(connection, sourceNodeVm, targetNodeVm);
        Connections.Add(connVm);

        StatusMessage = $"Connected {sourceNode.Name} -> {targetNode.Name}";
    }

    public void DeleteConnection(ConnectionViewModel connectionVm)
    {
        if (connectionVm == null) return;

        // Remove from graph
        Graph.Disconnect(connectionVm.Connection);

        // Remove from UI
        Connections.Remove(connectionVm);

        StatusMessage = "Connection deleted";
    }

    public void UpdateConnectionPositions()
    {
        foreach (var conn in Connections)
        {
            conn.UpdatePositions();
        }
    }

    public void DeleteNode(NodeViewModel nodeVm)
    {
        if (nodeVm == null) return;

        // Remove connections referencing this node first
        var toRemove = Connections.Where(c =>
            c.Connection.SourceNodeId == nodeVm.Node.Id ||
            c.Connection.TargetNodeId == nodeVm.Node.Id).ToList();
        foreach (var connVm in toRemove)
        {
            Graph.Disconnect(connVm.Connection);
            Connections.Remove(connVm);
        }

        // Remove node from graph and UI
        Graph.RemoveNode(nodeVm.Node);
        Nodes.Remove(nodeVm);

        StatusMessage = $"Deleted node: {nodeVm.Name}";
    }

    public void SelectNode(NodeViewModel? nodeVm)
    {
        // Deselect all nodes first
        foreach (var node in Nodes)
        {
            node.IsSelected = false;
        }

        // Default hide ROI filter toggle
        IsRoiFilterToggleVisible = false;
        _selectedRoiFilterNode = null;

        // Select the new node
        if (nodeVm != null)
        {
            nodeVm.IsSelected = true;
            SelectedNode = nodeVm;

            // Enable ROI drawing mode if this is a ROI Draw node
            if (nodeVm.Name == "ROI Draw")
            {
                IsRoiDrawingMode = true;
                SelectedRoiNode = nodeVm;
                UpdateRoiVisualization(nodeVm);
                StatusMessage = "ROI Drawing Mode: Click on 3D viewer to set ROI bounds";
            }
            else
            {
                IsRoiDrawingMode = false;
                SelectedRoiNode = null;
                RoiWireframeGeometry = null;
                RoiCenterPointGeometry = null;
            }

            // If ROI Filter node selected, show toggle in 3D viewer
            if (nodeVm.Name == "ROI Filter")
            {
                IsRoiFilterToggleVisible = true;
                _selectedRoiFilterNode = nodeVm;
            }
        }
        else
        {
            SelectedNode = null;
            IsRoiDrawingMode = false;
            SelectedRoiNode = null;
            RoiWireframeGeometry = null;
            RoiCenterPointGeometry = null;
        }

        // Update visualization to reflect possible filter toggle visibility change
        UpdateVisualization();
    }

    public void UpdateRoiFromParameters(NodeViewModel roiNodeVm)
    {
        if (roiNodeVm?.Node == null) return;

        var centerX = GetParameterValue<float>(roiNodeVm.Node, "CenterX");
        var centerY = GetParameterValue<float>(roiNodeVm.Node, "CenterY");
        var centerZ = GetParameterValue<float>(roiNodeVm.Node, "CenterZ");
        var sizeX = GetParameterValue<float>(roiNodeVm.Node, "SizeX");
        var sizeY = GetParameterValue<float>(roiNodeVm.Node, "SizeY");
        var sizeZ = GetParameterValue<float>(roiNodeVm.Node, "SizeZ");
        var radius = GetParameterValue<float>(roiNodeVm.Node, "Radius");
        var shapeStr = GetParameterValue<string>(roiNodeVm.Node, "Shape") ?? "Box";

        var shape = shapeStr.ToLower() switch
        {
            "cylinder" => ROIShape.Cylinder,
            "sphere" => ROIShape.Sphere,
            _ => ROIShape.Box
        };

        CreateRoiWireframe(new System.Numerics.Vector3(centerX, centerY, centerZ),
                          new System.Numerics.Vector3(sizeX, sizeY, sizeZ),
                          radius, shape);
    }

    private void UpdateRoiVisualization(NodeViewModel roiNodeVm)
    {
        UpdateRoiFromParameters(roiNodeVm);
    }

    private void CreateRoiWireframe(System.Numerics.Vector3 center, System.Numerics.Vector3 size, float radius, ROIShape shape)
    {
        var positions = new Vector3Collection();
        var indices = new IntCollection();

        if (shape == ROIShape.Box)
        {
            // Create box wireframe
            var hx = size.X / 2;
            var hy = size.Y / 2;
            var hz = size.Z / 2;

            // 8 corners of the box
            var corners = new[]
            {
                new Vector3(center.X - hx, center.Y - hy, center.Z - hz),
                new Vector3(center.X + hx, center.Y - hy, center.Z - hz),
                new Vector3(center.X + hx, center.Y + hy, center.Z - hz),
                new Vector3(center.X - hx, center.Y + hy, center.Z - hz),
                new Vector3(center.X - hx, center.Y - hy, center.Z + hz),
                new Vector3(center.X + hx, center.Y - hy, center.Z + hz),
                new Vector3(center.X + hx, center.Y + hy, center.Z + hz),
                new Vector3(center.X - hx, center.Y + hy, center.Z + hz),
            };

            foreach (var corner in corners)
                positions.Add(corner);

            // 12 edges of the box
            int[] edgeIndices = { 0,1, 1,2, 2,3, 3,0, 4,5, 5,6, 6,7, 7,4, 0,4, 1,5, 2,6, 3,7 };
            foreach (var idx in edgeIndices)
                indices.Add(idx);
        }
        else if (shape == ROIShape.Cylinder)
        {
            // Create cylinder wireframe
            int segments = 32;
            for (int i = 0; i < segments; i++)
            {
                float angle = i * 2 * MathF.PI / segments;
                float x = center.X + radius * MathF.Cos(angle);
                float z = center.Z + radius * MathF.Sin(angle);

                // Bottom circle
                positions.Add(new Vector3(x, center.Y - size.Y / 2, z));
                // Top circle
                positions.Add(new Vector3(x, center.Y + size.Y / 2, z));
            }

            // Bottom and top circles
            for (int i = 0; i < segments; i++)
            {
                int next = (i + 1) % segments;
                indices.Add(i * 2);
                indices.Add(next * 2);
                indices.Add(i * 2 + 1);
                indices.Add(next * 2 + 1);
            }

            // Vertical lines
            for (int i = 0; i < segments; i += segments / 8)
            {
                indices.Add(i * 2);
                indices.Add(i * 2 + 1);
            }
        }
        else if (shape == ROIShape.Sphere)
        {
            // Create sphere wireframe
            int segments = 32;
            int rings = 16;

            for (int ring = 0; ring <= rings; ring++)
            {
                float phi = ring * MathF.PI / rings;
                for (int seg = 0; seg < segments; seg++)
                {
                    float theta = seg * 2 * MathF.PI / segments;
                    float x = center.X + radius * MathF.Sin(phi) * MathF.Cos(theta);
                    float y = center.Y + radius * MathF.Cos(phi);
                    float z = center.Z + radius * MathF.Sin(phi) * MathF.Sin(theta);
                    positions.Add(new Vector3(x, y, z));
                }
            }

            // Create indices for latitude lines
            for (int ring = 0; ring < rings; ring++)
            {
                for (int seg = 0; seg < segments; seg++)
                {
                    int next = (seg + 1) % segments;
                    indices.Add(ring * segments + seg);
                    indices.Add(ring * segments + next);
                }
            }

            // Create indices for longitude lines
            for (int seg = 0; seg < segments; seg += segments / 8)
            {
                for (int ring = 0; ring < rings; ring++)
                {
                    indices.Add(ring * segments + seg);
                    indices.Add((ring + 1) * segments + seg);
                }
            }
        }

        RoiWireframeGeometry = new LineGeometry3D
        {
            Positions = positions,
            Indices = indices
        };

        // Create center point sphere
        CreateRoiCenterPoint(center);
    }

    private void CreateRoiCenterPoint(System.Numerics.Vector3 center)
    {
        // Create a small sphere at the center point
        var sphereRadius = RoiCenterSphereRadius;
        var segments = 12;
        var rings = 8;

        var positions = new Vector3Collection();
        var indices = new IntCollection();
        var normals = new Vector3Collection();
        var texCoords = new Vector2Collection();

        // Generate sphere vertices
        for (int ring = 0; ring <= rings; ring++)
        {
            float phi = ring * MathF.PI / rings;
            for (int seg = 0; seg <= segments; seg++)
            {
                float theta = seg * 2 * MathF.PI / segments;
                float x = center.X + sphereRadius * MathF.Sin(phi) * MathF.Cos(theta);
                float y = center.Y + sphereRadius * MathF.Cos(phi);
                float z = center.Z + sphereRadius * MathF.Sin(phi) * MathF.Sin(theta);

                positions.Add(new Vector3(x, y, z));

                // Normal
                var normal = System.Numerics.Vector3.Normalize(new System.Numerics.Vector3(
                    x - center.X, y - center.Y, z - center.Z));
                normals.Add(new Vector3(normal.X, normal.Y, normal.Z));

                // Texture coordinates
                texCoords.Add(new SharpDX.Vector2((float)seg / segments, (float)ring / rings));
            }
        }

        // Generate sphere indices
        for (int ring = 0; ring < rings; ring++)
        {
            for (int seg = 0; seg < segments; seg++)
            {
                int current = ring * (segments + 1) + seg;
                int next = current + segments + 1;

                indices.Add(current);
                indices.Add(next);
                indices.Add(current + 1);

                indices.Add(current + 1);
                indices.Add(next);
                indices.Add(next + 1);
            }
        }

        RoiCenterPointGeometry = new MeshGeometry3D
        {
            Positions = positions,
            Indices = indices,
            Normals = normals,
            TextureCoordinates = texCoords
        };

        // Ensure the color is red
        RoiCenterPointColor = Colors.Red;
    }

    private T GetParameterValue<T>(INode node, string paramName)
    {
        var param = node.Parameters.FirstOrDefault(p => p.Name == paramName);
        if (param?.Value is T value)
            return value;
        return default!;
    }
}

public partial class NodeViewModel : ObservableObject
{
    public INode Node { get; }

    [ObservableProperty] private double _x;
    [ObservableProperty] private double _y;
    [ObservableProperty] private bool _isSelected;
    [ObservableProperty] private bool _isExecuting;

    public string Name => Node.Name;
    public string Category => Node.Category;

    // New parameter-based system
    public IReadOnlyList<IParameter> Parameters => Node.Parameters;

    public NodeViewModel(INode node)
    {
        Node = node;
        if (node is NodeBase nb)
        {
            X = nb.X;
            Y = nb.Y;
        }
    }
}

public partial class ConnectionViewModel : ObservableObject
{
    public Connection Connection { get; }
    private readonly NodeViewModel _sourceNodeVm;
    private readonly NodeViewModel _targetNodeVm;

    [ObservableProperty] private System.Windows.Point _startPoint;
    [ObservableProperty] private System.Windows.Point _endPoint;
    [ObservableProperty] private System.Windows.Point _controlPoint1;
    [ObservableProperty] private System.Windows.Point _controlPoint2;

    // Expose a Geometry for binding (since PathFigure/BezierSegment points aren't dependency properties)
    public System.Windows.Media.PathGeometry PathGeometry
    {
        get
        {
            var figure = new System.Windows.Media.PathFigure { StartPoint = StartPoint };
            figure.Segments.Add(new System.Windows.Media.BezierSegment(ControlPoint1, ControlPoint2, EndPoint, true));
            return new System.Windows.Media.PathGeometry(new[] { figure });
        }
    }

    partial void OnStartPointChanged(System.Windows.Point value) => OnPropertyChanged(nameof(PathGeometry));
    partial void OnEndPointChanged(System.Windows.Point value) => OnPropertyChanged(nameof(PathGeometry));
    partial void OnControlPoint1Changed(System.Windows.Point value) => OnPropertyChanged(nameof(PathGeometry));
    partial void OnControlPoint2Changed(System.Windows.Point value) => OnPropertyChanged(nameof(PathGeometry));

    public ConnectionViewModel(Connection connection, NodeViewModel sourceNodeVm, NodeViewModel targetNodeVm)
    {
        Connection = connection;
        _sourceNodeVm = sourceNodeVm;
        _targetNodeVm = targetNodeVm;

        UpdatePositions();
    }

    public void UpdatePositions()
    {
        if (_sourceNodeVm == null || _targetNodeVm == null) return;

        const double nodeWidth = 150;
        const double titleBarHeight = 30;  // Title bar height
        const double portRowHeight = 28;   // Port row height
        const double portVerticalOffset = titleBarHeight + (portRowHeight / 2); // Center of port row

        // Connection from output port (right side) to input port (left side)
        // Output port is on the right edge
        StartPoint = new System.Windows.Point(
            _sourceNodeVm.X + nodeWidth,
            _sourceNodeVm.Y + portVerticalOffset);

        // Input port is on the left edge
        EndPoint = new System.Windows.Point(
            _targetNodeVm.X,
            _targetNodeVm.Y + portVerticalOffset);

        // Calculate bezier control points for curved connection
        var controlOffset = Math.Abs(EndPoint.X - StartPoint.X) / 2;
        ControlPoint1 = new System.Windows.Point(StartPoint.X + controlOffset, StartPoint.Y);
        ControlPoint2 = new System.Windows.Point(EndPoint.X - controlOffset, EndPoint.Y);
    }
}
